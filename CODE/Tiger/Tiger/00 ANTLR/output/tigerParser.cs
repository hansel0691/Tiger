//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g 2014-05-18 14:44:03

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class tigerParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ALIAS_DEC", "AND", "ARGUMENT", "ARRAY", "ARRAY_DEC", "ARRAY_FF_INDEX", "ARRAY_INDEX", "ARRAY_INIT", "ASSIGN", "BREAK", "CB", "CBRACE", "CC", "COLON", "COMMA", "COMMENT", "CP", "DEC_DIGIT", "DEC_LIST", "DIF", "DIV", "DO", "DOT", "DQUOTE", "ELSE", "END", "EQUAL", "ESC_SEQ", "EXPR_SEQ", "FIELDS_DEC", "FIELD_ACCESS", "FIELD_ASSIGN", "FIELD_DEC", "FOR", "FUNCTION", "FUNCTION_CALL", "FUNCTION_DEC", "GT", "GTE", "ID", "ID_ACCESS", "IF", "IN", "INT", "LET", "LETTER", "LT", "LTE", "MINUS", "MULT", "NIL", "OB", "OBRACE", "OC", "OF", "OP", "OR", "PLUS", "PROC_DEC", "PROGRAM", "RECORD_DEC", "RECORD_INIT", "SEMI", "STRING", "THEN", "TO", "TYPE", "UNARY_MINUS", "UNICODE_ESC", "VAR", "VAR_DEC", "WHILE", "WS"
	};
	public const int EOF=-1;
	public const int ALIAS_DEC=4;
	public const int AND=5;
	public const int ARGUMENT=6;
	public const int ARRAY=7;
	public const int ARRAY_DEC=8;
	public const int ARRAY_FF_INDEX=9;
	public const int ARRAY_INDEX=10;
	public const int ARRAY_INIT=11;
	public const int ASSIGN=12;
	public const int BREAK=13;
	public const int CB=14;
	public const int CBRACE=15;
	public const int CC=16;
	public const int COLON=17;
	public const int COMMA=18;
	public const int COMMENT=19;
	public const int CP=20;
	public const int DEC_DIGIT=21;
	public const int DEC_LIST=22;
	public const int DIF=23;
	public const int DIV=24;
	public const int DO=25;
	public const int DOT=26;
	public const int DQUOTE=27;
	public const int ELSE=28;
	public const int END=29;
	public const int EQUAL=30;
	public const int ESC_SEQ=31;
	public const int EXPR_SEQ=32;
	public const int FIELDS_DEC=33;
	public const int FIELD_ACCESS=34;
	public const int FIELD_ASSIGN=35;
	public const int FIELD_DEC=36;
	public const int FOR=37;
	public const int FUNCTION=38;
	public const int FUNCTION_CALL=39;
	public const int FUNCTION_DEC=40;
	public const int GT=41;
	public const int GTE=42;
	public const int ID=43;
	public const int ID_ACCESS=44;
	public const int IF=45;
	public const int IN=46;
	public const int INT=47;
	public const int LET=48;
	public const int LETTER=49;
	public const int LT=50;
	public const int LTE=51;
	public const int MINUS=52;
	public const int MULT=53;
	public const int NIL=54;
	public const int OB=55;
	public const int OBRACE=56;
	public const int OC=57;
	public const int OF=58;
	public const int OP=59;
	public const int OR=60;
	public const int PLUS=61;
	public const int PROC_DEC=62;
	public const int PROGRAM=63;
	public const int RECORD_DEC=64;
	public const int RECORD_INIT=65;
	public const int SEMI=66;
	public const int STRING=67;
	public const int THEN=68;
	public const int TO=69;
	public const int TYPE=70;
	public const int UNARY_MINUS=71;
	public const int UNICODE_ESC=72;
	public const int VAR=73;
	public const int VAR_DEC=74;
	public const int WHILE=75;
	public const int WS=76;

	public tigerParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public tigerParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return tigerParser.tokenNames; } }
	public override string GrammarFileName { get { return "E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_program();
	partial void LeaveRule_program();

	// $ANTLR start "program"
	// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:156:8: public program : expr EOF -> ^( PROGRAM expr ) ;
	[GrammarRule("program")]
	public AstParserRuleReturnScope<object, IToken> program()
	{
		EnterRule_program();
		EnterRule("program", 1);
		TraceIn("program", 1);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken EOF2 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expr1 = default(AstParserRuleReturnScope<object, IToken>);

		object EOF2_tree = default(object);
		RewriteRuleITokenStream stream_EOF=new RewriteRuleITokenStream(adaptor,"token EOF");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "program");
		DebugLocation(156, 4);
		try
		{
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:157:5: ( expr EOF -> ^( PROGRAM expr ) )
			DebugEnterAlt(1);
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:157:9: expr EOF
			{
			DebugLocation(157, 9);
			PushFollow(Follow._expr_in_program1232);
			expr1=expr();
			PopFollow();

			stream_expr.Add(expr1.Tree);
			DebugLocation(157, 14);
			EOF2=(IToken)Match(input,EOF,Follow._EOF_in_program1234);  
			stream_EOF.Add(EOF2);



			{
			// AST REWRITE
			// elements: expr
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 157:18: -> ^( PROGRAM expr )
			{
				DebugLocation(157, 21);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:157:21: ^( PROGRAM expr )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(157, 23);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(PROGRAM, "PROGRAM"), root_1);

				DebugLocation(157, 31);
				adaptor.AddChild(root_1, stream_expr.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("program", 1);
			LeaveRule("program", 1);
			LeaveRule_program();
		}
		DebugLocation(158, 4);
		} finally { DebugExitRule(GrammarFileName, "program"); }
		return retval;

	}
	// $ANTLR end "program"

	partial void EnterRule_expr();
	partial void LeaveRule_expr();

	// $ANTLR start "expr"
	// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:160:1: expr : ( return_expr | non_return_expr );
	[GrammarRule("expr")]
	private AstParserRuleReturnScope<object, IToken> expr()
	{
		EnterRule_expr();
		EnterRule("expr", 2);
		TraceIn("expr", 2);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> return_expr3 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> non_return_expr4 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "expr");
		DebugLocation(160, 4);
		try
		{
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:161:5: ( return_expr | non_return_expr )
			int alt1=2;
			try { DebugEnterDecision(1, false);
			int LA1_0 = input.LA(1);

			if ((LA1_0==ID||LA1_0==IF||(LA1_0>=INT && LA1_0<=LET)||LA1_0==MINUS||LA1_0==NIL||LA1_0==OP||LA1_0==STRING))
			{
				alt1 = 1;
			}
			else if ((LA1_0==BREAK||LA1_0==FOR||LA1_0==WHILE))
			{
				alt1 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 1, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:161:9: return_expr
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(161, 9);
				PushFollow(Follow._return_expr_in_expr1261);
				return_expr3=return_expr();
				PopFollow();

				adaptor.AddChild(root_0, return_expr3.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:162:9: non_return_expr
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(162, 9);
				PushFollow(Follow._non_return_expr_in_expr1271);
				non_return_expr4=non_return_expr();
				PopFollow();

				adaptor.AddChild(root_0, non_return_expr4.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expr", 2);
			LeaveRule("expr", 2);
			LeaveRule_expr();
		}
		DebugLocation(163, 4);
		} finally { DebugExitRule(GrammarFileName, "expr"); }
		return retval;

	}
	// $ANTLR end "expr"

	partial void EnterRule_return_expr();
	partial void LeaveRule_return_expr();

	// $ANTLR start "return_expr"
	// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:165:1: return_expr : binary_expression ;
	[GrammarRule("return_expr")]
	private AstParserRuleReturnScope<object, IToken> return_expr()
	{
		EnterRule_return_expr();
		EnterRule("return_expr", 3);
		TraceIn("return_expr", 3);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> binary_expression5 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "return_expr");
		DebugLocation(165, 4);
		try
		{
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:166:5: ( binary_expression )
			DebugEnterAlt(1);
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:166:9: binary_expression
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(166, 9);
			PushFollow(Follow._binary_expression_in_return_expr1290);
			binary_expression5=binary_expression();
			PopFollow();

			adaptor.AddChild(root_0, binary_expression5.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("return_expr", 3);
			LeaveRule("return_expr", 3);
			LeaveRule_return_expr();
		}
		DebugLocation(167, 4);
		} finally { DebugExitRule(GrammarFileName, "return_expr"); }
		return retval;

	}
	// $ANTLR end "return_expr"

	partial void EnterRule_non_return_expr();
	partial void LeaveRule_non_return_expr();

	// $ANTLR start "non_return_expr"
	// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:170:1: non_return_expr : ( WHILE cond= return_expr DO loop= expr -> ^( WHILE $cond $loop) | FOR ID ASSIGN init= return_expr TO end= return_expr DO loop= expr -> ^( FOR ID $init $end $loop) | BREAK );
	[GrammarRule("non_return_expr")]
	private AstParserRuleReturnScope<object, IToken> non_return_expr()
	{
		EnterRule_non_return_expr();
		EnterRule("non_return_expr", 4);
		TraceIn("non_return_expr", 4);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken WHILE6 = default(IToken);
		IToken DO7 = default(IToken);
		IToken FOR8 = default(IToken);
		IToken ID9 = default(IToken);
		IToken ASSIGN10 = default(IToken);
		IToken TO11 = default(IToken);
		IToken DO12 = default(IToken);
		IToken BREAK13 = default(IToken);
		AstParserRuleReturnScope<object, IToken> cond = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> loop = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> init = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> end = default(AstParserRuleReturnScope<object, IToken>);

		object WHILE6_tree = default(object);
		object DO7_tree = default(object);
		object FOR8_tree = default(object);
		object ID9_tree = default(object);
		object ASSIGN10_tree = default(object);
		object TO11_tree = default(object);
		object DO12_tree = default(object);
		object BREAK13_tree = default(object);
		RewriteRuleITokenStream stream_FOR=new RewriteRuleITokenStream(adaptor,"token FOR");
		RewriteRuleITokenStream stream_DO=new RewriteRuleITokenStream(adaptor,"token DO");
		RewriteRuleITokenStream stream_WHILE=new RewriteRuleITokenStream(adaptor,"token WHILE");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_TO=new RewriteRuleITokenStream(adaptor,"token TO");
		RewriteRuleITokenStream stream_ASSIGN=new RewriteRuleITokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		RewriteRuleSubtreeStream stream_return_expr=new RewriteRuleSubtreeStream(adaptor,"rule return_expr");
		try { DebugEnterRule(GrammarFileName, "non_return_expr");
		DebugLocation(170, 4);
		try
		{
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:171:5: ( WHILE cond= return_expr DO loop= expr -> ^( WHILE $cond $loop) | FOR ID ASSIGN init= return_expr TO end= return_expr DO loop= expr -> ^( FOR ID $init $end $loop) | BREAK )
			int alt2=3;
			try { DebugEnterDecision(2, false);
			switch (input.LA(1))
			{
			case WHILE:
				{
				alt2 = 1;
				}
				break;
			case FOR:
				{
				alt2 = 2;
				}
				break;
			case BREAK:
				{
				alt2 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 2, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:171:9: WHILE cond= return_expr DO loop= expr
				{
				DebugLocation(171, 9);
				WHILE6=(IToken)Match(input,WHILE,Follow._WHILE_in_non_return_expr1318);  
				stream_WHILE.Add(WHILE6);

				DebugLocation(171, 19);
				PushFollow(Follow._return_expr_in_non_return_expr1322);
				cond=return_expr();
				PopFollow();

				stream_return_expr.Add(cond.Tree);
				DebugLocation(171, 32);
				DO7=(IToken)Match(input,DO,Follow._DO_in_non_return_expr1324);  
				stream_DO.Add(DO7);

				DebugLocation(171, 39);
				PushFollow(Follow._expr_in_non_return_expr1328);
				loop=expr();
				PopFollow();

				stream_expr.Add(loop.Tree);


				{
				// AST REWRITE
				// elements: loop, WHILE, cond
				// token labels: 
				// rule labels: retval, loop, cond
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_loop=new RewriteRuleSubtreeStream(adaptor,"rule loop",loop!=null?loop.Tree:null);
				RewriteRuleSubtreeStream stream_cond=new RewriteRuleSubtreeStream(adaptor,"rule cond",cond!=null?cond.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 171:45: -> ^( WHILE $cond $loop)
				{
					DebugLocation(171, 48);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:171:48: ^( WHILE $cond $loop)
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(171, 50);
					root_1 = (object)adaptor.BecomeRoot(stream_WHILE.NextNode(), root_1);

					DebugLocation(171, 57);
					adaptor.AddChild(root_1, stream_cond.NextTree());
					DebugLocation(171, 63);
					adaptor.AddChild(root_1, stream_loop.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:172:9: FOR ID ASSIGN init= return_expr TO end= return_expr DO loop= expr
				{
				DebugLocation(172, 9);
				FOR8=(IToken)Match(input,FOR,Follow._FOR_in_non_return_expr1351);  
				stream_FOR.Add(FOR8);

				DebugLocation(172, 13);
				ID9=(IToken)Match(input,ID,Follow._ID_in_non_return_expr1353);  
				stream_ID.Add(ID9);

				DebugLocation(172, 16);
				ASSIGN10=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_non_return_expr1355);  
				stream_ASSIGN.Add(ASSIGN10);

				DebugLocation(172, 27);
				PushFollow(Follow._return_expr_in_non_return_expr1359);
				init=return_expr();
				PopFollow();

				stream_return_expr.Add(init.Tree);
				DebugLocation(172, 40);
				TO11=(IToken)Match(input,TO,Follow._TO_in_non_return_expr1361);  
				stream_TO.Add(TO11);

				DebugLocation(172, 46);
				PushFollow(Follow._return_expr_in_non_return_expr1365);
				end=return_expr();
				PopFollow();

				stream_return_expr.Add(end.Tree);
				DebugLocation(172, 59);
				DO12=(IToken)Match(input,DO,Follow._DO_in_non_return_expr1367);  
				stream_DO.Add(DO12);

				DebugLocation(172, 66);
				PushFollow(Follow._expr_in_non_return_expr1371);
				loop=expr();
				PopFollow();

				stream_expr.Add(loop.Tree);


				{
				// AST REWRITE
				// elements: init, FOR, loop, ID, end
				// token labels: 
				// rule labels: retval, loop, init, end
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_loop=new RewriteRuleSubtreeStream(adaptor,"rule loop",loop!=null?loop.Tree:null);
				RewriteRuleSubtreeStream stream_init=new RewriteRuleSubtreeStream(adaptor,"rule init",init!=null?init.Tree:null);
				RewriteRuleSubtreeStream stream_end=new RewriteRuleSubtreeStream(adaptor,"rule end",end!=null?end.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 172:72: -> ^( FOR ID $init $end $loop)
				{
					DebugLocation(172, 75);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:172:75: ^( FOR ID $init $end $loop)
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(172, 77);
					root_1 = (object)adaptor.BecomeRoot(stream_FOR.NextNode(), root_1);

					DebugLocation(172, 82);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(172, 86);
					adaptor.AddChild(root_1, stream_init.NextTree());
					DebugLocation(172, 92);
					adaptor.AddChild(root_1, stream_end.NextTree());
					DebugLocation(172, 97);
					adaptor.AddChild(root_1, stream_loop.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:173:9: BREAK
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(173, 9);
				BREAK13=(IToken)Match(input,BREAK,Follow._BREAK_in_non_return_expr1400); 
				BREAK13_tree = (object)adaptor.Create(BREAK13);
				adaptor.AddChild(root_0, BREAK13_tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("non_return_expr", 4);
			LeaveRule("non_return_expr", 4);
			LeaveRule_non_return_expr();
		}
		DebugLocation(174, 4);
		} finally { DebugExitRule(GrammarFileName, "non_return_expr"); }
		return retval;

	}
	// $ANTLR end "non_return_expr"

	partial void EnterRule_binary_expression();
	partial void LeaveRule_binary_expression();

	// $ANTLR start "binary_expression"
	// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:176:1: binary_expression : and_expression ( OR ^ and_expression )* ;
	[GrammarRule("binary_expression")]
	private AstParserRuleReturnScope<object, IToken> binary_expression()
	{
		EnterRule_binary_expression();
		EnterRule("binary_expression", 5);
		TraceIn("binary_expression", 5);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken OR15 = default(IToken);
		AstParserRuleReturnScope<object, IToken> and_expression14 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> and_expression16 = default(AstParserRuleReturnScope<object, IToken>);

		object OR15_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "binary_expression");
		DebugLocation(176, 8);
		try
		{
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:177:5: ( and_expression ( OR ^ and_expression )* )
			DebugEnterAlt(1);
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:177:9: and_expression ( OR ^ and_expression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(177, 9);
			PushFollow(Follow._and_expression_in_binary_expression1424);
			and_expression14=and_expression();
			PopFollow();

			adaptor.AddChild(root_0, and_expression14.Tree);
			DebugLocation(177, 24);
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:177:24: ( OR ^ and_expression )*
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=2;
				try { DebugEnterDecision(3, false);
				int LA3_0 = input.LA(1);

				if ((LA3_0==OR))
				{
					alt3 = 1;
				}


				} finally { DebugExitDecision(3); }
				switch ( alt3 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:177:25: OR ^ and_expression
					{
					DebugLocation(177, 27);
					OR15=(IToken)Match(input,OR,Follow._OR_in_binary_expression1427); 
					OR15_tree = (object)adaptor.Create(OR15);
					root_0 = (object)adaptor.BecomeRoot(OR15_tree, root_0);
					DebugLocation(177, 29);
					PushFollow(Follow._and_expression_in_binary_expression1430);
					and_expression16=and_expression();
					PopFollow();

					adaptor.AddChild(root_0, and_expression16.Tree);

					}
					break;

				default:
					goto loop3;
				}
			}

			loop3:
				;

			} finally { DebugExitSubRule(3); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("binary_expression", 5);
			LeaveRule("binary_expression", 5);
			LeaveRule_binary_expression();
		}
		DebugLocation(178, 8);
		} finally { DebugExitRule(GrammarFileName, "binary_expression"); }
		return retval;

	}
	// $ANTLR end "binary_expression"

	partial void EnterRule_and_expression();
	partial void LeaveRule_and_expression();

	// $ANTLR start "and_expression"
	// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:180:1: and_expression : comparison_expression ( AND ^ comparison_expression )* ;
	[GrammarRule("and_expression")]
	private AstParserRuleReturnScope<object, IToken> and_expression()
	{
		EnterRule_and_expression();
		EnterRule("and_expression", 6);
		TraceIn("and_expression", 6);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken AND18 = default(IToken);
		AstParserRuleReturnScope<object, IToken> comparison_expression17 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> comparison_expression19 = default(AstParserRuleReturnScope<object, IToken>);

		object AND18_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "and_expression");
		DebugLocation(180, 4);
		try
		{
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:181:5: ( comparison_expression ( AND ^ comparison_expression )* )
			DebugEnterAlt(1);
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:181:9: comparison_expression ( AND ^ comparison_expression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(181, 9);
			PushFollow(Follow._comparison_expression_in_and_expression1455);
			comparison_expression17=comparison_expression();
			PopFollow();

			adaptor.AddChild(root_0, comparison_expression17.Tree);
			DebugLocation(181, 31);
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:181:31: ( AND ^ comparison_expression )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				int LA4_0 = input.LA(1);

				if ((LA4_0==AND))
				{
					alt4 = 1;
				}


				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:181:32: AND ^ comparison_expression
					{
					DebugLocation(181, 35);
					AND18=(IToken)Match(input,AND,Follow._AND_in_and_expression1458); 
					AND18_tree = (object)adaptor.Create(AND18);
					root_0 = (object)adaptor.BecomeRoot(AND18_tree, root_0);
					DebugLocation(181, 37);
					PushFollow(Follow._comparison_expression_in_and_expression1461);
					comparison_expression19=comparison_expression();
					PopFollow();

					adaptor.AddChild(root_0, comparison_expression19.Tree);

					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("and_expression", 6);
			LeaveRule("and_expression", 6);
			LeaveRule_and_expression();
		}
		DebugLocation(182, 4);
		} finally { DebugExitRule(GrammarFileName, "and_expression"); }
		return retval;

	}
	// $ANTLR end "and_expression"

	partial void EnterRule_comparison_expression();
	partial void LeaveRule_comparison_expression();

	// $ANTLR start "comparison_expression"
	// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:184:1: comparison_expression : addition_expression ( ( EQUAL ^| DIF ^| LT ^| LTE ^| GT ^| GTE ^) addition_expression )? ;
	[GrammarRule("comparison_expression")]
	private AstParserRuleReturnScope<object, IToken> comparison_expression()
	{
		EnterRule_comparison_expression();
		EnterRule("comparison_expression", 7);
		TraceIn("comparison_expression", 7);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken EQUAL21 = default(IToken);
		IToken DIF22 = default(IToken);
		IToken LT23 = default(IToken);
		IToken LTE24 = default(IToken);
		IToken GT25 = default(IToken);
		IToken GTE26 = default(IToken);
		AstParserRuleReturnScope<object, IToken> addition_expression20 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> addition_expression27 = default(AstParserRuleReturnScope<object, IToken>);

		object EQUAL21_tree = default(object);
		object DIF22_tree = default(object);
		object LT23_tree = default(object);
		object LTE24_tree = default(object);
		object GT25_tree = default(object);
		object GTE26_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "comparison_expression");
		DebugLocation(184, 4);
		try
		{
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:185:5: ( addition_expression ( ( EQUAL ^| DIF ^| LT ^| LTE ^| GT ^| GTE ^) addition_expression )? )
			DebugEnterAlt(1);
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:185:9: addition_expression ( ( EQUAL ^| DIF ^| LT ^| LTE ^| GT ^| GTE ^) addition_expression )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(185, 9);
			PushFollow(Follow._addition_expression_in_comparison_expression1482);
			addition_expression20=addition_expression();
			PopFollow();

			adaptor.AddChild(root_0, addition_expression20.Tree);
			DebugLocation(185, 29);
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:185:29: ( ( EQUAL ^| DIF ^| LT ^| LTE ^| GT ^| GTE ^) addition_expression )?
			int alt6=2;
			try { DebugEnterSubRule(6);
			try { DebugEnterDecision(6, false);
			switch (input.LA(1))
			{
			case EQUAL:
				{
				alt6 = 1;
				}
				break;
			case DIF:
				{
				alt6 = 1;
				}
				break;
			case LT:
				{
				alt6 = 1;
				}
				break;
			case LTE:
				{
				alt6 = 1;
				}
				break;
			case GT:
				{
				alt6 = 1;
				}
				break;
			case GTE:
				{
				alt6 = 1;
				}
				break;
			}

			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:185:30: ( EQUAL ^| DIF ^| LT ^| LTE ^| GT ^| GTE ^) addition_expression
				{
				DebugLocation(185, 30);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:185:30: ( EQUAL ^| DIF ^| LT ^| LTE ^| GT ^| GTE ^)
				int alt5=6;
				try { DebugEnterSubRule(5);
				try { DebugEnterDecision(5, false);
				switch (input.LA(1))
				{
				case EQUAL:
					{
					alt5 = 1;
					}
					break;
				case DIF:
					{
					alt5 = 2;
					}
					break;
				case LT:
					{
					alt5 = 3;
					}
					break;
				case LTE:
					{
					alt5 = 4;
					}
					break;
				case GT:
					{
					alt5 = 5;
					}
					break;
				case GTE:
					{
					alt5 = 6;
					}
					break;
				default:
					{
						NoViableAltException nvae = new NoViableAltException("", 5, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				} finally { DebugExitDecision(5); }
				switch (alt5)
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:185:31: EQUAL ^
					{
					DebugLocation(185, 36);
					EQUAL21=(IToken)Match(input,EQUAL,Follow._EQUAL_in_comparison_expression1486); 
					EQUAL21_tree = (object)adaptor.Create(EQUAL21);
					root_0 = (object)adaptor.BecomeRoot(EQUAL21_tree, root_0);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:185:38: DIF ^
					{
					DebugLocation(185, 41);
					DIF22=(IToken)Match(input,DIF,Follow._DIF_in_comparison_expression1489); 
					DIF22_tree = (object)adaptor.Create(DIF22);
					root_0 = (object)adaptor.BecomeRoot(DIF22_tree, root_0);

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:185:43: LT ^
					{
					DebugLocation(185, 45);
					LT23=(IToken)Match(input,LT,Follow._LT_in_comparison_expression1492); 
					LT23_tree = (object)adaptor.Create(LT23);
					root_0 = (object)adaptor.BecomeRoot(LT23_tree, root_0);

					}
					break;
				case 4:
					DebugEnterAlt(4);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:185:48: LTE ^
					{
					DebugLocation(185, 51);
					LTE24=(IToken)Match(input,LTE,Follow._LTE_in_comparison_expression1496); 
					LTE24_tree = (object)adaptor.Create(LTE24);
					root_0 = (object)adaptor.BecomeRoot(LTE24_tree, root_0);

					}
					break;
				case 5:
					DebugEnterAlt(5);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:185:54: GT ^
					{
					DebugLocation(185, 56);
					GT25=(IToken)Match(input,GT,Follow._GT_in_comparison_expression1500); 
					GT25_tree = (object)adaptor.Create(GT25);
					root_0 = (object)adaptor.BecomeRoot(GT25_tree, root_0);

					}
					break;
				case 6:
					DebugEnterAlt(6);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:185:59: GTE ^
					{
					DebugLocation(185, 62);
					GTE26=(IToken)Match(input,GTE,Follow._GTE_in_comparison_expression1504); 
					GTE26_tree = (object)adaptor.Create(GTE26);
					root_0 = (object)adaptor.BecomeRoot(GTE26_tree, root_0);

					}
					break;

				}
				} finally { DebugExitSubRule(5); }

				DebugLocation(185, 65);
				PushFollow(Follow._addition_expression_in_comparison_expression1508);
				addition_expression27=addition_expression();
				PopFollow();

				adaptor.AddChild(root_0, addition_expression27.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(6); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("comparison_expression", 7);
			LeaveRule("comparison_expression", 7);
			LeaveRule_comparison_expression();
		}
		DebugLocation(186, 4);
		} finally { DebugExitRule(GrammarFileName, "comparison_expression"); }
		return retval;

	}
	// $ANTLR end "comparison_expression"

	partial void EnterRule_addition_expression();
	partial void LeaveRule_addition_expression();

	// $ANTLR start "addition_expression"
	// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:188:1: addition_expression : term ( ( PLUS ^| MINUS ^) term )* ;
	[GrammarRule("addition_expression")]
	private AstParserRuleReturnScope<object, IToken> addition_expression()
	{
		EnterRule_addition_expression();
		EnterRule("addition_expression", 8);
		TraceIn("addition_expression", 8);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken PLUS29 = default(IToken);
		IToken MINUS30 = default(IToken);
		AstParserRuleReturnScope<object, IToken> term28 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> term31 = default(AstParserRuleReturnScope<object, IToken>);

		object PLUS29_tree = default(object);
		object MINUS30_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "addition_expression");
		DebugLocation(188, 4);
		try
		{
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:189:5: ( term ( ( PLUS ^| MINUS ^) term )* )
			DebugEnterAlt(1);
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:189:9: term ( ( PLUS ^| MINUS ^) term )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(189, 9);
			PushFollow(Follow._term_in_addition_expression1529);
			term28=term();
			PopFollow();

			adaptor.AddChild(root_0, term28.Tree);
			DebugLocation(189, 14);
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:189:14: ( ( PLUS ^| MINUS ^) term )*
			try { DebugEnterSubRule(8);
			while (true)
			{
				int alt8=2;
				try { DebugEnterDecision(8, false);
				int LA8_0 = input.LA(1);

				if ((LA8_0==PLUS))
				{
					alt8 = 1;
				}
				else if ((LA8_0==MINUS))
				{
					alt8 = 1;
				}


				} finally { DebugExitDecision(8); }
				switch ( alt8 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:189:15: ( PLUS ^| MINUS ^) term
					{
					DebugLocation(189, 15);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:189:15: ( PLUS ^| MINUS ^)
					int alt7=2;
					try { DebugEnterSubRule(7);
					try { DebugEnterDecision(7, false);
					int LA7_0 = input.LA(1);

					if ((LA7_0==PLUS))
					{
						alt7 = 1;
					}
					else if ((LA7_0==MINUS))
					{
						alt7 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 7, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(7); }
					switch (alt7)
					{
					case 1:
						DebugEnterAlt(1);
						// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:189:16: PLUS ^
						{
						DebugLocation(189, 20);
						PLUS29=(IToken)Match(input,PLUS,Follow._PLUS_in_addition_expression1533); 
						PLUS29_tree = (object)adaptor.Create(PLUS29);
						root_0 = (object)adaptor.BecomeRoot(PLUS29_tree, root_0);

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:189:22: MINUS ^
						{
						DebugLocation(189, 27);
						MINUS30=(IToken)Match(input,MINUS,Follow._MINUS_in_addition_expression1536); 
						MINUS30_tree = (object)adaptor.Create(MINUS30);
						root_0 = (object)adaptor.BecomeRoot(MINUS30_tree, root_0);

						}
						break;

					}
					} finally { DebugExitSubRule(7); }

					DebugLocation(189, 30);
					PushFollow(Follow._term_in_addition_expression1540);
					term31=term();
					PopFollow();

					adaptor.AddChild(root_0, term31.Tree);

					}
					break;

				default:
					goto loop8;
				}
			}

			loop8:
				;

			} finally { DebugExitSubRule(8); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("addition_expression", 8);
			LeaveRule("addition_expression", 8);
			LeaveRule_addition_expression();
		}
		DebugLocation(190, 4);
		} finally { DebugExitRule(GrammarFileName, "addition_expression"); }
		return retval;

	}
	// $ANTLR end "addition_expression"

	partial void EnterRule_term();
	partial void LeaveRule_term();

	// $ANTLR start "term"
	// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:192:1: term : factor ( ( MULT ^| DIV ^) factor )* ;
	[GrammarRule("term")]
	private AstParserRuleReturnScope<object, IToken> term()
	{
		EnterRule_term();
		EnterRule("term", 9);
		TraceIn("term", 9);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken MULT33 = default(IToken);
		IToken DIV34 = default(IToken);
		AstParserRuleReturnScope<object, IToken> factor32 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> factor35 = default(AstParserRuleReturnScope<object, IToken>);

		object MULT33_tree = default(object);
		object DIV34_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "term");
		DebugLocation(192, 4);
		try
		{
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:193:5: ( factor ( ( MULT ^| DIV ^) factor )* )
			DebugEnterAlt(1);
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:193:9: factor ( ( MULT ^| DIV ^) factor )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(193, 9);
			PushFollow(Follow._factor_in_term1561);
			factor32=factor();
			PopFollow();

			adaptor.AddChild(root_0, factor32.Tree);
			DebugLocation(193, 16);
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:193:16: ( ( MULT ^| DIV ^) factor )*
			try { DebugEnterSubRule(10);
			while (true)
			{
				int alt10=2;
				try { DebugEnterDecision(10, false);
				int LA10_0 = input.LA(1);

				if ((LA10_0==MULT))
				{
					alt10 = 1;
				}
				else if ((LA10_0==DIV))
				{
					alt10 = 1;
				}


				} finally { DebugExitDecision(10); }
				switch ( alt10 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:193:17: ( MULT ^| DIV ^) factor
					{
					DebugLocation(193, 17);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:193:17: ( MULT ^| DIV ^)
					int alt9=2;
					try { DebugEnterSubRule(9);
					try { DebugEnterDecision(9, false);
					int LA9_0 = input.LA(1);

					if ((LA9_0==MULT))
					{
						alt9 = 1;
					}
					else if ((LA9_0==DIV))
					{
						alt9 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 9, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(9); }
					switch (alt9)
					{
					case 1:
						DebugEnterAlt(1);
						// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:193:18: MULT ^
						{
						DebugLocation(193, 22);
						MULT33=(IToken)Match(input,MULT,Follow._MULT_in_term1565); 
						MULT33_tree = (object)adaptor.Create(MULT33);
						root_0 = (object)adaptor.BecomeRoot(MULT33_tree, root_0);

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:193:24: DIV ^
						{
						DebugLocation(193, 27);
						DIV34=(IToken)Match(input,DIV,Follow._DIV_in_term1568); 
						DIV34_tree = (object)adaptor.Create(DIV34);
						root_0 = (object)adaptor.BecomeRoot(DIV34_tree, root_0);

						}
						break;

					}
					} finally { DebugExitSubRule(9); }

					DebugLocation(193, 30);
					PushFollow(Follow._factor_in_term1572);
					factor35=factor();
					PopFollow();

					adaptor.AddChild(root_0, factor35.Tree);

					}
					break;

				default:
					goto loop10;
				}
			}

			loop10:
				;

			} finally { DebugExitSubRule(10); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("term", 9);
			LeaveRule("term", 9);
			LeaveRule_term();
		}
		DebugLocation(194, 4);
		} finally { DebugExitRule(GrammarFileName, "term"); }
		return retval;

	}
	// $ANTLR end "term"

	partial void EnterRule_factor();
	partial void LeaveRule_factor();

	// $ANTLR start "factor"
	// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:196:1: factor : ( INT | MINUS factor -> ^( UNARY_MINUS factor ) | IF cond= return_expr THEN then= expr ( ELSE else_do= expr )? -> ^( IF $cond $then ( $else_do)? ) | LET declaration_list IN ( expr_seq )? END -> ^( LET declaration_list ^( EXPR_SEQ ( expr_seq )? ) ) | STRING | NIL | id_expr | OP ( expr_seq )? CP -> ^( EXPR_SEQ ( expr_seq )? ) );
	[GrammarRule("factor")]
	private AstParserRuleReturnScope<object, IToken> factor()
	{
		EnterRule_factor();
		EnterRule("factor", 10);
		TraceIn("factor", 10);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken INT36 = default(IToken);
		IToken MINUS37 = default(IToken);
		IToken IF39 = default(IToken);
		IToken THEN40 = default(IToken);
		IToken ELSE41 = default(IToken);
		IToken LET42 = default(IToken);
		IToken IN44 = default(IToken);
		IToken END46 = default(IToken);
		IToken STRING47 = default(IToken);
		IToken NIL48 = default(IToken);
		IToken OP50 = default(IToken);
		IToken CP52 = default(IToken);
		AstParserRuleReturnScope<object, IToken> cond = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> then = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> else_do = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> factor38 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> declaration_list43 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr_seq45 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> id_expr49 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr_seq51 = default(AstParserRuleReturnScope<object, IToken>);

		object INT36_tree = default(object);
		object MINUS37_tree = default(object);
		object IF39_tree = default(object);
		object THEN40_tree = default(object);
		object ELSE41_tree = default(object);
		object LET42_tree = default(object);
		object IN44_tree = default(object);
		object END46_tree = default(object);
		object STRING47_tree = default(object);
		object NIL48_tree = default(object);
		object OP50_tree = default(object);
		object CP52_tree = default(object);
		RewriteRuleITokenStream stream_IN=new RewriteRuleITokenStream(adaptor,"token IN");
		RewriteRuleITokenStream stream_THEN=new RewriteRuleITokenStream(adaptor,"token THEN");
		RewriteRuleITokenStream stream_MINUS=new RewriteRuleITokenStream(adaptor,"token MINUS");
		RewriteRuleITokenStream stream_END=new RewriteRuleITokenStream(adaptor,"token END");
		RewriteRuleITokenStream stream_CP=new RewriteRuleITokenStream(adaptor,"token CP");
		RewriteRuleITokenStream stream_OP=new RewriteRuleITokenStream(adaptor,"token OP");
		RewriteRuleITokenStream stream_LET=new RewriteRuleITokenStream(adaptor,"token LET");
		RewriteRuleITokenStream stream_IF=new RewriteRuleITokenStream(adaptor,"token IF");
		RewriteRuleITokenStream stream_ELSE=new RewriteRuleITokenStream(adaptor,"token ELSE");
		RewriteRuleSubtreeStream stream_declaration_list=new RewriteRuleSubtreeStream(adaptor,"rule declaration_list");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		RewriteRuleSubtreeStream stream_factor=new RewriteRuleSubtreeStream(adaptor,"rule factor");
		RewriteRuleSubtreeStream stream_return_expr=new RewriteRuleSubtreeStream(adaptor,"rule return_expr");
		RewriteRuleSubtreeStream stream_expr_seq=new RewriteRuleSubtreeStream(adaptor,"rule expr_seq");
		try { DebugEnterRule(GrammarFileName, "factor");
		DebugLocation(196, 4);
		try
		{
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:197:5: ( INT | MINUS factor -> ^( UNARY_MINUS factor ) | IF cond= return_expr THEN then= expr ( ELSE else_do= expr )? -> ^( IF $cond $then ( $else_do)? ) | LET declaration_list IN ( expr_seq )? END -> ^( LET declaration_list ^( EXPR_SEQ ( expr_seq )? ) ) | STRING | NIL | id_expr | OP ( expr_seq )? CP -> ^( EXPR_SEQ ( expr_seq )? ) )
			int alt14=8;
			try { DebugEnterDecision(14, false);
			switch (input.LA(1))
			{
			case INT:
				{
				alt14 = 1;
				}
				break;
			case MINUS:
				{
				alt14 = 2;
				}
				break;
			case IF:
				{
				alt14 = 3;
				}
				break;
			case LET:
				{
				alt14 = 4;
				}
				break;
			case STRING:
				{
				alt14 = 5;
				}
				break;
			case NIL:
				{
				alt14 = 6;
				}
				break;
			case ID:
				{
				alt14 = 7;
				}
				break;
			case OP:
				{
				alt14 = 8;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 14, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(14); }
			switch (alt14)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:197:9: INT
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(197, 9);
				INT36=(IToken)Match(input,INT,Follow._INT_in_factor1593); 
				INT36_tree = (object)adaptor.Create(INT36);
				adaptor.AddChild(root_0, INT36_tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:198:9: MINUS factor
				{
				DebugLocation(198, 9);
				MINUS37=(IToken)Match(input,MINUS,Follow._MINUS_in_factor1604);  
				stream_MINUS.Add(MINUS37);

				DebugLocation(198, 15);
				PushFollow(Follow._factor_in_factor1606);
				factor38=factor();
				PopFollow();

				stream_factor.Add(factor38.Tree);


				{
				// AST REWRITE
				// elements: factor
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 198:22: -> ^( UNARY_MINUS factor )
				{
					DebugLocation(198, 25);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:198:25: ^( UNARY_MINUS factor )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(198, 27);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(UNARY_MINUS, "UNARY_MINUS"), root_1);

					DebugLocation(198, 39);
					adaptor.AddChild(root_1, stream_factor.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:199:8: IF cond= return_expr THEN then= expr ( ELSE else_do= expr )?
				{
				DebugLocation(199, 8);
				IF39=(IToken)Match(input,IF,Follow._IF_in_factor1623);  
				stream_IF.Add(IF39);

				DebugLocation(199, 16);
				PushFollow(Follow._return_expr_in_factor1629);
				cond=return_expr();
				PopFollow();

				stream_return_expr.Add(cond.Tree);
				DebugLocation(199, 30);
				THEN40=(IToken)Match(input,THEN,Follow._THEN_in_factor1631);  
				stream_THEN.Add(THEN40);

				DebugLocation(199, 39);
				PushFollow(Follow._expr_in_factor1635);
				then=expr();
				PopFollow();

				stream_expr.Add(then.Tree);
				DebugLocation(199, 45);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:199:45: ( ELSE else_do= expr )?
				int alt11=2;
				try { DebugEnterSubRule(11);
				try { DebugEnterDecision(11, false);
				int LA11_0 = input.LA(1);

				if ((LA11_0==ELSE))
				{
					alt11 = 1;
				}
				} finally { DebugExitDecision(11); }
				switch (alt11)
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:199:46: ELSE else_do= expr
					{
					DebugLocation(199, 46);
					ELSE41=(IToken)Match(input,ELSE,Follow._ELSE_in_factor1638);  
					stream_ELSE.Add(ELSE41);

					DebugLocation(199, 58);
					PushFollow(Follow._expr_in_factor1642);
					else_do=expr();
					PopFollow();

					stream_expr.Add(else_do.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(11); }



				{
				// AST REWRITE
				// elements: IF, cond, else_do, then
				// token labels: 
				// rule labels: else_do, retval, then, cond
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_else_do=new RewriteRuleSubtreeStream(adaptor,"rule else_do",else_do!=null?else_do.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_then=new RewriteRuleSubtreeStream(adaptor,"rule then",then!=null?then.Tree:null);
				RewriteRuleSubtreeStream stream_cond=new RewriteRuleSubtreeStream(adaptor,"rule cond",cond!=null?cond.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 199:66: -> ^( IF $cond $then ( $else_do)? )
				{
					DebugLocation(199, 69);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:199:69: ^( IF $cond $then ( $else_do)? )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(199, 71);
					root_1 = (object)adaptor.BecomeRoot(stream_IF.NextNode(), root_1);

					DebugLocation(199, 75);
					adaptor.AddChild(root_1, stream_cond.NextTree());
					DebugLocation(199, 81);
					adaptor.AddChild(root_1, stream_then.NextTree());
					DebugLocation(199, 87);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:199:87: ( $else_do)?
					if (stream_else_do.HasNext)
					{
						DebugLocation(199, 87);
						adaptor.AddChild(root_1, stream_else_do.NextTree());

					}
					stream_else_do.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:200:9: LET declaration_list IN ( expr_seq )? END
				{
				DebugLocation(200, 9);
				LET42=(IToken)Match(input,LET,Follow._LET_in_factor1670);  
				stream_LET.Add(LET42);

				DebugLocation(200, 13);
				PushFollow(Follow._declaration_list_in_factor1672);
				declaration_list43=declaration_list();
				PopFollow();

				stream_declaration_list.Add(declaration_list43.Tree);
				DebugLocation(200, 30);
				IN44=(IToken)Match(input,IN,Follow._IN_in_factor1674);  
				stream_IN.Add(IN44);

				DebugLocation(200, 33);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:200:33: ( expr_seq )?
				int alt12=2;
				try { DebugEnterSubRule(12);
				try { DebugEnterDecision(12, false);
				int LA12_0 = input.LA(1);

				if ((LA12_0==BREAK||LA12_0==FOR||LA12_0==ID||LA12_0==IF||(LA12_0>=INT && LA12_0<=LET)||LA12_0==MINUS||LA12_0==NIL||LA12_0==OP||LA12_0==STRING||LA12_0==WHILE))
				{
					alt12 = 1;
				}
				} finally { DebugExitDecision(12); }
				switch (alt12)
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:200:33: expr_seq
					{
					DebugLocation(200, 33);
					PushFollow(Follow._expr_seq_in_factor1676);
					expr_seq45=expr_seq();
					PopFollow();

					stream_expr_seq.Add(expr_seq45.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(12); }

				DebugLocation(200, 44);
				END46=(IToken)Match(input,END,Follow._END_in_factor1680);  
				stream_END.Add(END46);



				{
				// AST REWRITE
				// elements: expr_seq, declaration_list, LET
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 200:48: -> ^( LET declaration_list ^( EXPR_SEQ ( expr_seq )? ) )
				{
					DebugLocation(200, 51);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:200:51: ^( LET declaration_list ^( EXPR_SEQ ( expr_seq )? ) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(200, 53);
					root_1 = (object)adaptor.BecomeRoot(stream_LET.NextNode(), root_1);

					DebugLocation(200, 57);
					adaptor.AddChild(root_1, stream_declaration_list.NextTree());
					DebugLocation(200, 74);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:200:74: ^( EXPR_SEQ ( expr_seq )? )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(200, 76);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(EXPR_SEQ, "EXPR_SEQ"), root_2);

					DebugLocation(200, 85);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:200:85: ( expr_seq )?
					if (stream_expr_seq.HasNext)
					{
						DebugLocation(200, 85);
						adaptor.AddChild(root_2, stream_expr_seq.NextTree());

					}
					stream_expr_seq.Reset();

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:201:9: STRING
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(201, 9);
				STRING47=(IToken)Match(input,STRING,Follow._STRING_in_factor1706); 
				STRING47_tree = (object)adaptor.Create(STRING47);
				adaptor.AddChild(root_0, STRING47_tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:202:9: NIL
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(202, 9);
				NIL48=(IToken)Match(input,NIL,Follow._NIL_in_factor1716); 
				NIL48_tree = (object)adaptor.Create(NIL48);
				adaptor.AddChild(root_0, NIL48_tree);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:203:9: id_expr
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(203, 9);
				PushFollow(Follow._id_expr_in_factor1726);
				id_expr49=id_expr();
				PopFollow();

				adaptor.AddChild(root_0, id_expr49.Tree);

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:204:9: OP ( expr_seq )? CP
				{
				DebugLocation(204, 9);
				OP50=(IToken)Match(input,OP,Follow._OP_in_factor1736);  
				stream_OP.Add(OP50);

				DebugLocation(204, 12);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:204:12: ( expr_seq )?
				int alt13=2;
				try { DebugEnterSubRule(13);
				try { DebugEnterDecision(13, false);
				int LA13_0 = input.LA(1);

				if ((LA13_0==BREAK||LA13_0==FOR||LA13_0==ID||LA13_0==IF||(LA13_0>=INT && LA13_0<=LET)||LA13_0==MINUS||LA13_0==NIL||LA13_0==OP||LA13_0==STRING||LA13_0==WHILE))
				{
					alt13 = 1;
				}
				} finally { DebugExitDecision(13); }
				switch (alt13)
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:204:12: expr_seq
					{
					DebugLocation(204, 12);
					PushFollow(Follow._expr_seq_in_factor1738);
					expr_seq51=expr_seq();
					PopFollow();

					stream_expr_seq.Add(expr_seq51.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(13); }

				DebugLocation(204, 22);
				CP52=(IToken)Match(input,CP,Follow._CP_in_factor1741);  
				stream_CP.Add(CP52);



				{
				// AST REWRITE
				// elements: expr_seq
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 204:25: -> ^( EXPR_SEQ ( expr_seq )? )
				{
					DebugLocation(204, 28);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:204:28: ^( EXPR_SEQ ( expr_seq )? )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(204, 30);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(EXPR_SEQ, "EXPR_SEQ"), root_1);

					DebugLocation(204, 39);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:204:39: ( expr_seq )?
					if (stream_expr_seq.HasNext)
					{
						DebugLocation(204, 39);
						adaptor.AddChild(root_1, stream_expr_seq.NextTree());

					}
					stream_expr_seq.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("factor", 10);
			LeaveRule("factor", 10);
			LeaveRule_factor();
		}
		DebugLocation(205, 4);
		} finally { DebugExitRule(GrammarFileName, "factor"); }
		return retval;

	}
	// $ANTLR end "factor"

	partial void EnterRule_indexer_expr();
	partial void LeaveRule_indexer_expr();

	// $ANTLR start "indexer_expr"
	// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:207:1: indexer_expr : ( DOT ID ( indexer_expr )? -> ^( DOT ID ( indexer_expr )? ) | OB return_expr CB ( indexer_expr )? -> ^( ARRAY_FF_INDEX return_expr ( indexer_expr )? ) );
	[GrammarRule("indexer_expr")]
	private AstParserRuleReturnScope<object, IToken> indexer_expr()
	{
		EnterRule_indexer_expr();
		EnterRule("indexer_expr", 11);
		TraceIn("indexer_expr", 11);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken DOT53 = default(IToken);
		IToken ID54 = default(IToken);
		IToken OB56 = default(IToken);
		IToken CB58 = default(IToken);
		AstParserRuleReturnScope<object, IToken> indexer_expr55 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> return_expr57 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> indexer_expr59 = default(AstParserRuleReturnScope<object, IToken>);

		object DOT53_tree = default(object);
		object ID54_tree = default(object);
		object OB56_tree = default(object);
		object CB58_tree = default(object);
		RewriteRuleITokenStream stream_DOT=new RewriteRuleITokenStream(adaptor,"token DOT");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_CB=new RewriteRuleITokenStream(adaptor,"token CB");
		RewriteRuleITokenStream stream_OB=new RewriteRuleITokenStream(adaptor,"token OB");
		RewriteRuleSubtreeStream stream_indexer_expr=new RewriteRuleSubtreeStream(adaptor,"rule indexer_expr");
		RewriteRuleSubtreeStream stream_return_expr=new RewriteRuleSubtreeStream(adaptor,"rule return_expr");
		try { DebugEnterRule(GrammarFileName, "indexer_expr");
		DebugLocation(207, 4);
		try
		{
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:208:5: ( DOT ID ( indexer_expr )? -> ^( DOT ID ( indexer_expr )? ) | OB return_expr CB ( indexer_expr )? -> ^( ARRAY_FF_INDEX return_expr ( indexer_expr )? ) )
			int alt17=2;
			try { DebugEnterDecision(17, false);
			int LA17_0 = input.LA(1);

			if ((LA17_0==DOT))
			{
				alt17 = 1;
			}
			else if ((LA17_0==OB))
			{
				alt17 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 17, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(17); }
			switch (alt17)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:208:9: DOT ID ( indexer_expr )?
				{
				DebugLocation(208, 9);
				DOT53=(IToken)Match(input,DOT,Follow._DOT_in_indexer_expr1770);  
				stream_DOT.Add(DOT53);

				DebugLocation(208, 13);
				ID54=(IToken)Match(input,ID,Follow._ID_in_indexer_expr1772);  
				stream_ID.Add(ID54);

				DebugLocation(208, 16);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:208:16: ( indexer_expr )?
				int alt15=2;
				try { DebugEnterSubRule(15);
				try { DebugEnterDecision(15, false);
				int LA15_0 = input.LA(1);

				if ((LA15_0==DOT||LA15_0==OB))
				{
					alt15 = 1;
				}
				} finally { DebugExitDecision(15); }
				switch (alt15)
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:208:16: indexer_expr
					{
					DebugLocation(208, 16);
					PushFollow(Follow._indexer_expr_in_indexer_expr1774);
					indexer_expr55=indexer_expr();
					PopFollow();

					stream_indexer_expr.Add(indexer_expr55.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(15); }



				{
				// AST REWRITE
				// elements: DOT, indexer_expr, ID
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 208:30: -> ^( DOT ID ( indexer_expr )? )
				{
					DebugLocation(208, 33);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:208:33: ^( DOT ID ( indexer_expr )? )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(208, 35);
					root_1 = (object)adaptor.BecomeRoot(stream_DOT.NextNode(), root_1);

					DebugLocation(208, 39);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(208, 42);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:208:42: ( indexer_expr )?
					if (stream_indexer_expr.HasNext)
					{
						DebugLocation(208, 42);
						adaptor.AddChild(root_1, stream_indexer_expr.NextTree());

					}
					stream_indexer_expr.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:209:9: OB return_expr CB ( indexer_expr )?
				{
				DebugLocation(209, 9);
				OB56=(IToken)Match(input,OB,Follow._OB_in_indexer_expr1796);  
				stream_OB.Add(OB56);

				DebugLocation(209, 12);
				PushFollow(Follow._return_expr_in_indexer_expr1798);
				return_expr57=return_expr();
				PopFollow();

				stream_return_expr.Add(return_expr57.Tree);
				DebugLocation(209, 24);
				CB58=(IToken)Match(input,CB,Follow._CB_in_indexer_expr1800);  
				stream_CB.Add(CB58);

				DebugLocation(209, 27);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:209:27: ( indexer_expr )?
				int alt16=2;
				try { DebugEnterSubRule(16);
				try { DebugEnterDecision(16, false);
				int LA16_0 = input.LA(1);

				if ((LA16_0==DOT||LA16_0==OB))
				{
					alt16 = 1;
				}
				} finally { DebugExitDecision(16); }
				switch (alt16)
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:209:27: indexer_expr
					{
					DebugLocation(209, 27);
					PushFollow(Follow._indexer_expr_in_indexer_expr1802);
					indexer_expr59=indexer_expr();
					PopFollow();

					stream_indexer_expr.Add(indexer_expr59.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(16); }



				{
				// AST REWRITE
				// elements: return_expr, indexer_expr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 209:41: -> ^( ARRAY_FF_INDEX return_expr ( indexer_expr )? )
				{
					DebugLocation(209, 44);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:209:44: ^( ARRAY_FF_INDEX return_expr ( indexer_expr )? )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(209, 46);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ARRAY_FF_INDEX, "ARRAY_FF_INDEX"), root_1);

					DebugLocation(209, 61);
					adaptor.AddChild(root_1, stream_return_expr.NextTree());
					DebugLocation(209, 73);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:209:73: ( indexer_expr )?
					if (stream_indexer_expr.HasNext)
					{
						DebugLocation(209, 73);
						adaptor.AddChild(root_1, stream_indexer_expr.NextTree());

					}
					stream_indexer_expr.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("indexer_expr", 11);
			LeaveRule("indexer_expr", 11);
			LeaveRule_indexer_expr();
		}
		DebugLocation(210, 4);
		} finally { DebugExitRule(GrammarFileName, "indexer_expr"); }
		return retval;

	}
	// $ANTLR end "indexer_expr"

	partial void EnterRule_id_expr();
	partial void LeaveRule_id_expr();

	// $ANTLR start "id_expr"
	// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:212:1: id_expr : id= ID ( OBRACE ( field_list )? CBRACE -> ^( RECORD_INIT $id ( field_list )? ) | OB length_index= return_expr CB ( OF value= return_expr -> ^( ARRAY_INIT $id $length_index $value) | ( indexer_expr )? ( ( ASSIGN value= return_expr ) -> ^( ASSIGN ^( ARRAY_INDEX $id ^( ARRAY_FF_INDEX $length_index ( indexer_expr )? ) ) $value) | -> ^( ARRAY_INDEX $id ^( ARRAY_FF_INDEX $length_index ( indexer_expr )? ) ) ) ) | DOT access= ID ( indexer_expr )? ( ASSIGN asignation_value= return_expr -> ^( ASSIGN ^( FIELD_ACCESS $id ^( DOT $access ( indexer_expr )? ) ) $asignation_value) | -> ^( FIELD_ACCESS $id ^( DOT $access ( indexer_expr )? ) ) ) | OP ( expr_list )? CP -> ^( FUNCTION_CALL $id ( expr_list )? ) | ASSIGN rvalue= return_expr -> ^( ASSIGN $id $rvalue) | -> $id) ;
	[GrammarRule("id_expr")]
	private AstParserRuleReturnScope<object, IToken> id_expr()
	{
		EnterRule_id_expr();
		EnterRule("id_expr", 12);
		TraceIn("id_expr", 12);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken id = default(IToken);
		IToken access = default(IToken);
		IToken OBRACE60 = default(IToken);
		IToken CBRACE62 = default(IToken);
		IToken OB63 = default(IToken);
		IToken CB64 = default(IToken);
		IToken OF65 = default(IToken);
		IToken ASSIGN67 = default(IToken);
		IToken DOT68 = default(IToken);
		IToken ASSIGN70 = default(IToken);
		IToken OP71 = default(IToken);
		IToken CP73 = default(IToken);
		IToken ASSIGN74 = default(IToken);
		AstParserRuleReturnScope<object, IToken> length_index = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> value = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> asignation_value = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> rvalue = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> field_list61 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> indexer_expr66 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> indexer_expr69 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr_list72 = default(AstParserRuleReturnScope<object, IToken>);

		object id_tree = default(object);
		object access_tree = default(object);
		object OBRACE60_tree = default(object);
		object CBRACE62_tree = default(object);
		object OB63_tree = default(object);
		object CB64_tree = default(object);
		object OF65_tree = default(object);
		object ASSIGN67_tree = default(object);
		object DOT68_tree = default(object);
		object ASSIGN70_tree = default(object);
		object OP71_tree = default(object);
		object CP73_tree = default(object);
		object ASSIGN74_tree = default(object);
		RewriteRuleITokenStream stream_OBRACE=new RewriteRuleITokenStream(adaptor,"token OBRACE");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_DOT=new RewriteRuleITokenStream(adaptor,"token DOT");
		RewriteRuleITokenStream stream_OF=new RewriteRuleITokenStream(adaptor,"token OF");
		RewriteRuleITokenStream stream_CB=new RewriteRuleITokenStream(adaptor,"token CB");
		RewriteRuleITokenStream stream_CBRACE=new RewriteRuleITokenStream(adaptor,"token CBRACE");
		RewriteRuleITokenStream stream_CP=new RewriteRuleITokenStream(adaptor,"token CP");
		RewriteRuleITokenStream stream_OP=new RewriteRuleITokenStream(adaptor,"token OP");
		RewriteRuleITokenStream stream_OB=new RewriteRuleITokenStream(adaptor,"token OB");
		RewriteRuleITokenStream stream_ASSIGN=new RewriteRuleITokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_indexer_expr=new RewriteRuleSubtreeStream(adaptor,"rule indexer_expr");
		RewriteRuleSubtreeStream stream_field_list=new RewriteRuleSubtreeStream(adaptor,"rule field_list");
		RewriteRuleSubtreeStream stream_return_expr=new RewriteRuleSubtreeStream(adaptor,"rule return_expr");
		RewriteRuleSubtreeStream stream_expr_list=new RewriteRuleSubtreeStream(adaptor,"rule expr_list");
		try { DebugEnterRule(GrammarFileName, "id_expr");
		DebugLocation(212, 4);
		try
		{
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:213:5: (id= ID ( OBRACE ( field_list )? CBRACE -> ^( RECORD_INIT $id ( field_list )? ) | OB length_index= return_expr CB ( OF value= return_expr -> ^( ARRAY_INIT $id $length_index $value) | ( indexer_expr )? ( ( ASSIGN value= return_expr ) -> ^( ASSIGN ^( ARRAY_INDEX $id ^( ARRAY_FF_INDEX $length_index ( indexer_expr )? ) ) $value) | -> ^( ARRAY_INDEX $id ^( ARRAY_FF_INDEX $length_index ( indexer_expr )? ) ) ) ) | DOT access= ID ( indexer_expr )? ( ASSIGN asignation_value= return_expr -> ^( ASSIGN ^( FIELD_ACCESS $id ^( DOT $access ( indexer_expr )? ) ) $asignation_value) | -> ^( FIELD_ACCESS $id ^( DOT $access ( indexer_expr )? ) ) ) | OP ( expr_list )? CP -> ^( FUNCTION_CALL $id ( expr_list )? ) | ASSIGN rvalue= return_expr -> ^( ASSIGN $id $rvalue) | -> $id) )
			DebugEnterAlt(1);
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:213:9: id= ID ( OBRACE ( field_list )? CBRACE -> ^( RECORD_INIT $id ( field_list )? ) | OB length_index= return_expr CB ( OF value= return_expr -> ^( ARRAY_INIT $id $length_index $value) | ( indexer_expr )? ( ( ASSIGN value= return_expr ) -> ^( ASSIGN ^( ARRAY_INDEX $id ^( ARRAY_FF_INDEX $length_index ( indexer_expr )? ) ) $value) | -> ^( ARRAY_INDEX $id ^( ARRAY_FF_INDEX $length_index ( indexer_expr )? ) ) ) ) | DOT access= ID ( indexer_expr )? ( ASSIGN asignation_value= return_expr -> ^( ASSIGN ^( FIELD_ACCESS $id ^( DOT $access ( indexer_expr )? ) ) $asignation_value) | -> ^( FIELD_ACCESS $id ^( DOT $access ( indexer_expr )? ) ) ) | OP ( expr_list )? CP -> ^( FUNCTION_CALL $id ( expr_list )? ) | ASSIGN rvalue= return_expr -> ^( ASSIGN $id $rvalue) | -> $id)
			{
			DebugLocation(213, 11);
			id=(IToken)Match(input,ID,Follow._ID_in_id_expr1835);  
			stream_ID.Add(id);

			DebugLocation(214, 5);
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:214:5: ( OBRACE ( field_list )? CBRACE -> ^( RECORD_INIT $id ( field_list )? ) | OB length_index= return_expr CB ( OF value= return_expr -> ^( ARRAY_INIT $id $length_index $value) | ( indexer_expr )? ( ( ASSIGN value= return_expr ) -> ^( ASSIGN ^( ARRAY_INDEX $id ^( ARRAY_FF_INDEX $length_index ( indexer_expr )? ) ) $value) | -> ^( ARRAY_INDEX $id ^( ARRAY_FF_INDEX $length_index ( indexer_expr )? ) ) ) ) | DOT access= ID ( indexer_expr )? ( ASSIGN asignation_value= return_expr -> ^( ASSIGN ^( FIELD_ACCESS $id ^( DOT $access ( indexer_expr )? ) ) $asignation_value) | -> ^( FIELD_ACCESS $id ^( DOT $access ( indexer_expr )? ) ) ) | OP ( expr_list )? CP -> ^( FUNCTION_CALL $id ( expr_list )? ) | ASSIGN rvalue= return_expr -> ^( ASSIGN $id $rvalue) | -> $id)
			int alt25=6;
			try { DebugEnterSubRule(25);
			try { DebugEnterDecision(25, false);
			switch (input.LA(1))
			{
			case OBRACE:
				{
				alt25 = 1;
				}
				break;
			case OB:
				{
				alt25 = 2;
				}
				break;
			case DOT:
				{
				alt25 = 3;
				}
				break;
			case OP:
				{
				alt25 = 4;
				}
				break;
			case ASSIGN:
				{
				alt25 = 5;
				}
				break;
			case EOF:
			case AND:
			case CB:
			case CBRACE:
			case COMMA:
			case CP:
			case DIF:
			case DIV:
			case DO:
			case ELSE:
			case END:
			case EQUAL:
			case FUNCTION:
			case GT:
			case GTE:
			case IN:
			case LT:
			case LTE:
			case MINUS:
			case MULT:
			case OR:
			case PLUS:
			case SEMI:
			case THEN:
			case TO:
			case TYPE:
			case VAR:
				{
				alt25 = 6;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 25, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(25); }
			switch (alt25)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:216:9: OBRACE ( field_list )? CBRACE
				{
				DebugLocation(216, 9);
				OBRACE60=(IToken)Match(input,OBRACE,Follow._OBRACE_in_id_expr1861);  
				stream_OBRACE.Add(OBRACE60);

				DebugLocation(216, 16);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:216:16: ( field_list )?
				int alt18=2;
				try { DebugEnterSubRule(18);
				try { DebugEnterDecision(18, false);
				int LA18_0 = input.LA(1);

				if ((LA18_0==ID))
				{
					alt18 = 1;
				}
				} finally { DebugExitDecision(18); }
				switch (alt18)
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:216:16: field_list
					{
					DebugLocation(216, 16);
					PushFollow(Follow._field_list_in_id_expr1863);
					field_list61=field_list();
					PopFollow();

					stream_field_list.Add(field_list61.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(18); }

				DebugLocation(216, 28);
				CBRACE62=(IToken)Match(input,CBRACE,Follow._CBRACE_in_id_expr1866);  
				stream_CBRACE.Add(CBRACE62);



				{
				// AST REWRITE
				// elements: id, field_list
				// token labels: id
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleITokenStream stream_id=new RewriteRuleITokenStream(adaptor,"token id",id);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 216:36: -> ^( RECORD_INIT $id ( field_list )? )
				{
					DebugLocation(216, 39);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:216:39: ^( RECORD_INIT $id ( field_list )? )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(216, 41);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(RECORD_INIT, "RECORD_INIT"), root_1);

					DebugLocation(216, 54);
					adaptor.AddChild(root_1, stream_id.NextNode());
					DebugLocation(216, 57);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:216:57: ( field_list )?
					if (stream_field_list.HasNext)
					{
						DebugLocation(216, 57);
						adaptor.AddChild(root_1, stream_field_list.NextTree());

					}
					stream_field_list.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:218:11: OB length_index= return_expr CB ( OF value= return_expr -> ^( ARRAY_INIT $id $length_index $value) | ( indexer_expr )? ( ( ASSIGN value= return_expr ) -> ^( ASSIGN ^( ARRAY_INDEX $id ^( ARRAY_FF_INDEX $length_index ( indexer_expr )? ) ) $value) | -> ^( ARRAY_INDEX $id ^( ARRAY_FF_INDEX $length_index ( indexer_expr )? ) ) ) )
				{
				DebugLocation(218, 11);
				OB63=(IToken)Match(input,OB,Follow._OB_in_id_expr1916);  
				stream_OB.Add(OB63);

				DebugLocation(218, 26);
				PushFollow(Follow._return_expr_in_id_expr1920);
				length_index=return_expr();
				PopFollow();

				stream_return_expr.Add(length_index.Tree);
				DebugLocation(218, 39);
				CB64=(IToken)Match(input,CB,Follow._CB_in_id_expr1922);  
				stream_CB.Add(CB64);

				DebugLocation(219, 11);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:219:11: ( OF value= return_expr -> ^( ARRAY_INIT $id $length_index $value) | ( indexer_expr )? ( ( ASSIGN value= return_expr ) -> ^( ASSIGN ^( ARRAY_INDEX $id ^( ARRAY_FF_INDEX $length_index ( indexer_expr )? ) ) $value) | -> ^( ARRAY_INDEX $id ^( ARRAY_FF_INDEX $length_index ( indexer_expr )? ) ) ) )
				int alt21=2;
				try { DebugEnterSubRule(21);
				try { DebugEnterDecision(21, false);
				int LA21_0 = input.LA(1);

				if ((LA21_0==OF))
				{
					alt21 = 1;
				}
				else if ((LA21_0==EOF||LA21_0==AND||LA21_0==ASSIGN||(LA21_0>=CB && LA21_0<=CBRACE)||LA21_0==COMMA||LA21_0==CP||(LA21_0>=DIF && LA21_0<=DOT)||(LA21_0>=ELSE && LA21_0<=EQUAL)||LA21_0==FUNCTION||(LA21_0>=GT && LA21_0<=GTE)||LA21_0==IN||(LA21_0>=LT && LA21_0<=MULT)||LA21_0==OB||(LA21_0>=OR && LA21_0<=PLUS)||LA21_0==SEMI||(LA21_0>=THEN && LA21_0<=TYPE)||LA21_0==VAR))
				{
					alt21 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 21, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(21); }
				switch (alt21)
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:219:12: OF value= return_expr
					{
					DebugLocation(219, 12);
					OF65=(IToken)Match(input,OF,Follow._OF_in_id_expr1935);  
					stream_OF.Add(OF65);

					DebugLocation(219, 20);
					PushFollow(Follow._return_expr_in_id_expr1939);
					value=return_expr();
					PopFollow();

					stream_return_expr.Add(value.Tree);


					{
					// AST REWRITE
					// elements: id, length_index, value
					// token labels: id
					// rule labels: retval, length_index, value
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					retval.Tree = root_0;
					RewriteRuleITokenStream stream_id=new RewriteRuleITokenStream(adaptor,"token id",id);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
					RewriteRuleSubtreeStream stream_length_index=new RewriteRuleSubtreeStream(adaptor,"rule length_index",length_index!=null?length_index.Tree:null);
					RewriteRuleSubtreeStream stream_value=new RewriteRuleSubtreeStream(adaptor,"rule value",value!=null?value.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 219:33: -> ^( ARRAY_INIT $id $length_index $value)
					{
						DebugLocation(219, 36);
						// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:219:36: ^( ARRAY_INIT $id $length_index $value)
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(219, 38);
						root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ARRAY_INIT, "ARRAY_INIT"), root_1);

						DebugLocation(219, 50);
						adaptor.AddChild(root_1, stream_id.NextNode());
						DebugLocation(219, 54);
						adaptor.AddChild(root_1, stream_length_index.NextTree());
						DebugLocation(219, 68);
						adaptor.AddChild(root_1, stream_value.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:220:27: ( indexer_expr )? ( ( ASSIGN value= return_expr ) -> ^( ASSIGN ^( ARRAY_INDEX $id ^( ARRAY_FF_INDEX $length_index ( indexer_expr )? ) ) $value) | -> ^( ARRAY_INDEX $id ^( ARRAY_FF_INDEX $length_index ( indexer_expr )? ) ) )
					{
					DebugLocation(220, 27);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:220:27: ( indexer_expr )?
					int alt19=2;
					try { DebugEnterSubRule(19);
					try { DebugEnterDecision(19, false);
					int LA19_0 = input.LA(1);

					if ((LA19_0==DOT||LA19_0==OB))
					{
						alt19 = 1;
					}
					} finally { DebugExitDecision(19); }
					switch (alt19)
					{
					case 1:
						DebugEnterAlt(1);
						// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:220:27: indexer_expr
						{
						DebugLocation(220, 27);
						PushFollow(Follow._indexer_expr_in_id_expr1982);
						indexer_expr66=indexer_expr();
						PopFollow();

						stream_indexer_expr.Add(indexer_expr66.Tree);

						}
						break;

					}
					} finally { DebugExitSubRule(19); }

					DebugLocation(222, 29);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:222:29: ( ( ASSIGN value= return_expr ) -> ^( ASSIGN ^( ARRAY_INDEX $id ^( ARRAY_FF_INDEX $length_index ( indexer_expr )? ) ) $value) | -> ^( ARRAY_INDEX $id ^( ARRAY_FF_INDEX $length_index ( indexer_expr )? ) ) )
					int alt20=2;
					try { DebugEnterSubRule(20);
					try { DebugEnterDecision(20, false);
					int LA20_0 = input.LA(1);

					if ((LA20_0==ASSIGN))
					{
						alt20 = 1;
					}
					else if ((LA20_0==EOF||LA20_0==AND||(LA20_0>=CB && LA20_0<=CBRACE)||LA20_0==COMMA||LA20_0==CP||(LA20_0>=DIF && LA20_0<=DO)||(LA20_0>=ELSE && LA20_0<=EQUAL)||LA20_0==FUNCTION||(LA20_0>=GT && LA20_0<=GTE)||LA20_0==IN||(LA20_0>=LT && LA20_0<=MULT)||(LA20_0>=OR && LA20_0<=PLUS)||LA20_0==SEMI||(LA20_0>=THEN && LA20_0<=TYPE)||LA20_0==VAR))
					{
						alt20 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 20, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(20); }
					switch (alt20)
					{
					case 1:
						DebugEnterAlt(1);
						// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:222:30: ( ASSIGN value= return_expr )
						{
						DebugLocation(222, 30);
						// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:222:30: ( ASSIGN value= return_expr )
						DebugEnterAlt(1);
						// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:222:31: ASSIGN value= return_expr
						{
						DebugLocation(222, 31);
						ASSIGN67=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_id_expr2044);  
						stream_ASSIGN.Add(ASSIGN67);

						DebugLocation(222, 43);
						PushFollow(Follow._return_expr_in_id_expr2048);
						value=return_expr();
						PopFollow();

						stream_return_expr.Add(value.Tree);

						}



						{
						// AST REWRITE
						// elements: id, ASSIGN, value, length_index, indexer_expr
						// token labels: id
						// rule labels: retval, length_index, value
						// token list labels: 
						// rule list labels: 
						// wildcard labels: 
						retval.Tree = root_0;
						RewriteRuleITokenStream stream_id=new RewriteRuleITokenStream(adaptor,"token id",id);
						RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
						RewriteRuleSubtreeStream stream_length_index=new RewriteRuleSubtreeStream(adaptor,"rule length_index",length_index!=null?length_index.Tree:null);
						RewriteRuleSubtreeStream stream_value=new RewriteRuleSubtreeStream(adaptor,"rule value",value!=null?value.Tree:null);

						root_0 = (object)adaptor.Nil();
						// 222:57: -> ^( ASSIGN ^( ARRAY_INDEX $id ^( ARRAY_FF_INDEX $length_index ( indexer_expr )? ) ) $value)
						{
							DebugLocation(222, 60);
							// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:222:60: ^( ASSIGN ^( ARRAY_INDEX $id ^( ARRAY_FF_INDEX $length_index ( indexer_expr )? ) ) $value)
							{
							object root_1 = (object)adaptor.Nil();
							DebugLocation(222, 62);
							root_1 = (object)adaptor.BecomeRoot(stream_ASSIGN.NextNode(), root_1);

							DebugLocation(222, 69);
							// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:222:69: ^( ARRAY_INDEX $id ^( ARRAY_FF_INDEX $length_index ( indexer_expr )? ) )
							{
							object root_2 = (object)adaptor.Nil();
							DebugLocation(222, 71);
							root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(ARRAY_INDEX, "ARRAY_INDEX"), root_2);

							DebugLocation(222, 84);
							adaptor.AddChild(root_2, stream_id.NextNode());
							DebugLocation(222, 87);
							// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:222:87: ^( ARRAY_FF_INDEX $length_index ( indexer_expr )? )
							{
							object root_3 = (object)adaptor.Nil();
							DebugLocation(222, 89);
							root_3 = (object)adaptor.BecomeRoot((object)adaptor.Create(ARRAY_FF_INDEX, "ARRAY_FF_INDEX"), root_3);

							DebugLocation(222, 105);
							adaptor.AddChild(root_3, stream_length_index.NextTree());
							DebugLocation(222, 118);
							// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:222:118: ( indexer_expr )?
							if (stream_indexer_expr.HasNext)
							{
								DebugLocation(222, 118);
								adaptor.AddChild(root_3, stream_indexer_expr.NextTree());

							}
							stream_indexer_expr.Reset();

							adaptor.AddChild(root_2, root_3);
							}

							adaptor.AddChild(root_1, root_2);
							}
							DebugLocation(222, 136);
							adaptor.AddChild(root_1, stream_value.NextTree());

							adaptor.AddChild(root_0, root_1);
							}

						}

						retval.Tree = root_0;
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:224:31: 
						{

						{
						// AST REWRITE
						// elements: id, indexer_expr, length_index
						// token labels: id
						// rule labels: retval, length_index
						// token list labels: 
						// rule list labels: 
						// wildcard labels: 
						retval.Tree = root_0;
						RewriteRuleITokenStream stream_id=new RewriteRuleITokenStream(adaptor,"token id",id);
						RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
						RewriteRuleSubtreeStream stream_length_index=new RewriteRuleSubtreeStream(adaptor,"rule length_index",length_index!=null?length_index.Tree:null);

						root_0 = (object)adaptor.Nil();
						// 224:31: -> ^( ARRAY_INDEX $id ^( ARRAY_FF_INDEX $length_index ( indexer_expr )? ) )
						{
							DebugLocation(224, 34);
							// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:224:34: ^( ARRAY_INDEX $id ^( ARRAY_FF_INDEX $length_index ( indexer_expr )? ) )
							{
							object root_1 = (object)adaptor.Nil();
							DebugLocation(224, 36);
							root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ARRAY_INDEX, "ARRAY_INDEX"), root_1);

							DebugLocation(224, 49);
							adaptor.AddChild(root_1, stream_id.NextNode());
							DebugLocation(224, 52);
							// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:224:52: ^( ARRAY_FF_INDEX $length_index ( indexer_expr )? )
							{
							object root_2 = (object)adaptor.Nil();
							DebugLocation(224, 54);
							root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(ARRAY_FF_INDEX, "ARRAY_FF_INDEX"), root_2);

							DebugLocation(224, 70);
							adaptor.AddChild(root_2, stream_length_index.NextTree());
							DebugLocation(224, 83);
							// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:224:83: ( indexer_expr )?
							if (stream_indexer_expr.HasNext)
							{
								DebugLocation(224, 83);
								adaptor.AddChild(root_2, stream_indexer_expr.NextTree());

							}
							stream_indexer_expr.Reset();

							adaptor.AddChild(root_1, root_2);
							}

							adaptor.AddChild(root_0, root_1);
							}

						}

						retval.Tree = root_0;
						}

						}
						break;

					}
					} finally { DebugExitSubRule(20); }


					}
					break;

				}
				} finally { DebugExitSubRule(21); }


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:227:11: DOT access= ID ( indexer_expr )? ( ASSIGN asignation_value= return_expr -> ^( ASSIGN ^( FIELD_ACCESS $id ^( DOT $access ( indexer_expr )? ) ) $asignation_value) | -> ^( FIELD_ACCESS $id ^( DOT $access ( indexer_expr )? ) ) )
				{
				DebugLocation(227, 11);
				DOT68=(IToken)Match(input,DOT,Follow._DOT_in_id_expr2204);  
				stream_DOT.Add(DOT68);

				DebugLocation(227, 21);
				access=(IToken)Match(input,ID,Follow._ID_in_id_expr2208);  
				stream_ID.Add(access);

				DebugLocation(227, 25);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:227:25: ( indexer_expr )?
				int alt22=2;
				try { DebugEnterSubRule(22);
				try { DebugEnterDecision(22, false);
				int LA22_0 = input.LA(1);

				if ((LA22_0==DOT||LA22_0==OB))
				{
					alt22 = 1;
				}
				} finally { DebugExitDecision(22); }
				switch (alt22)
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:227:25: indexer_expr
					{
					DebugLocation(227, 25);
					PushFollow(Follow._indexer_expr_in_id_expr2210);
					indexer_expr69=indexer_expr();
					PopFollow();

					stream_indexer_expr.Add(indexer_expr69.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(22); }

				DebugLocation(229, 10);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:229:10: ( ASSIGN asignation_value= return_expr -> ^( ASSIGN ^( FIELD_ACCESS $id ^( DOT $access ( indexer_expr )? ) ) $asignation_value) | -> ^( FIELD_ACCESS $id ^( DOT $access ( indexer_expr )? ) ) )
				int alt23=2;
				try { DebugEnterSubRule(23);
				try { DebugEnterDecision(23, false);
				int LA23_0 = input.LA(1);

				if ((LA23_0==ASSIGN))
				{
					alt23 = 1;
				}
				else if ((LA23_0==EOF||LA23_0==AND||(LA23_0>=CB && LA23_0<=CBRACE)||LA23_0==COMMA||LA23_0==CP||(LA23_0>=DIF && LA23_0<=DO)||(LA23_0>=ELSE && LA23_0<=EQUAL)||LA23_0==FUNCTION||(LA23_0>=GT && LA23_0<=GTE)||LA23_0==IN||(LA23_0>=LT && LA23_0<=MULT)||(LA23_0>=OR && LA23_0<=PLUS)||LA23_0==SEMI||(LA23_0>=THEN && LA23_0<=TYPE)||LA23_0==VAR))
				{
					alt23 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 23, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(23); }
				switch (alt23)
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:229:11: ASSIGN asignation_value= return_expr
					{
					DebugLocation(229, 11);
					ASSIGN70=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_id_expr2233);  
					stream_ASSIGN.Add(ASSIGN70);

					DebugLocation(229, 34);
					PushFollow(Follow._return_expr_in_id_expr2237);
					asignation_value=return_expr();
					PopFollow();

					stream_return_expr.Add(asignation_value.Tree);


					{
					// AST REWRITE
					// elements: access, ASSIGN, indexer_expr, asignation_value, DOT, id
					// token labels: id, access
					// rule labels: retval, asignation_value
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					retval.Tree = root_0;
					RewriteRuleITokenStream stream_id=new RewriteRuleITokenStream(adaptor,"token id",id);
					RewriteRuleITokenStream stream_access=new RewriteRuleITokenStream(adaptor,"token access",access);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
					RewriteRuleSubtreeStream stream_asignation_value=new RewriteRuleSubtreeStream(adaptor,"rule asignation_value",asignation_value!=null?asignation_value.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 229:47: -> ^( ASSIGN ^( FIELD_ACCESS $id ^( DOT $access ( indexer_expr )? ) ) $asignation_value)
					{
						DebugLocation(229, 50);
						// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:229:50: ^( ASSIGN ^( FIELD_ACCESS $id ^( DOT $access ( indexer_expr )? ) ) $asignation_value)
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(229, 52);
						root_1 = (object)adaptor.BecomeRoot(stream_ASSIGN.NextNode(), root_1);

						DebugLocation(229, 59);
						// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:229:59: ^( FIELD_ACCESS $id ^( DOT $access ( indexer_expr )? ) )
						{
						object root_2 = (object)adaptor.Nil();
						DebugLocation(229, 61);
						root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(FIELD_ACCESS, "FIELD_ACCESS"), root_2);

						DebugLocation(229, 75);
						adaptor.AddChild(root_2, stream_id.NextNode());
						DebugLocation(229, 78);
						// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:229:78: ^( DOT $access ( indexer_expr )? )
						{
						object root_3 = (object)adaptor.Nil();
						DebugLocation(229, 80);
						root_3 = (object)adaptor.BecomeRoot(stream_DOT.NextNode(), root_3);

						DebugLocation(229, 85);
						adaptor.AddChild(root_3, stream_access.NextNode());
						DebugLocation(229, 92);
						// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:229:92: ( indexer_expr )?
						if (stream_indexer_expr.HasNext)
						{
							DebugLocation(229, 92);
							adaptor.AddChild(root_3, stream_indexer_expr.NextTree());

						}
						stream_indexer_expr.Reset();

						adaptor.AddChild(root_2, root_3);
						}

						adaptor.AddChild(root_1, root_2);
						}
						DebugLocation(229, 109);
						adaptor.AddChild(root_1, stream_asignation_value.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:231:12: 
					{

					{
					// AST REWRITE
					// elements: DOT, access, id, indexer_expr
					// token labels: id, access
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					retval.Tree = root_0;
					RewriteRuleITokenStream stream_id=new RewriteRuleITokenStream(adaptor,"token id",id);
					RewriteRuleITokenStream stream_access=new RewriteRuleITokenStream(adaptor,"token access",access);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 231:12: -> ^( FIELD_ACCESS $id ^( DOT $access ( indexer_expr )? ) )
					{
						DebugLocation(231, 15);
						// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:231:15: ^( FIELD_ACCESS $id ^( DOT $access ( indexer_expr )? ) )
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(231, 17);
						root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FIELD_ACCESS, "FIELD_ACCESS"), root_1);

						DebugLocation(231, 31);
						adaptor.AddChild(root_1, stream_id.NextNode());
						DebugLocation(231, 34);
						// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:231:34: ^( DOT $access ( indexer_expr )? )
						{
						object root_2 = (object)adaptor.Nil();
						DebugLocation(231, 36);
						root_2 = (object)adaptor.BecomeRoot(stream_DOT.NextNode(), root_2);

						DebugLocation(231, 41);
						adaptor.AddChild(root_2, stream_access.NextNode());
						DebugLocation(231, 48);
						// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:231:48: ( indexer_expr )?
						if (stream_indexer_expr.HasNext)
						{
							DebugLocation(231, 48);
							adaptor.AddChild(root_2, stream_indexer_expr.NextTree());

						}
						stream_indexer_expr.Reset();

						adaptor.AddChild(root_1, root_2);
						}

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}

					}
					break;

				}
				} finally { DebugExitSubRule(23); }


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:234:11: OP ( expr_list )? CP
				{
				DebugLocation(234, 11);
				OP71=(IToken)Match(input,OP,Follow._OP_in_id_expr2336);  
				stream_OP.Add(OP71);

				DebugLocation(234, 14);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:234:14: ( expr_list )?
				int alt24=2;
				try { DebugEnterSubRule(24);
				try { DebugEnterDecision(24, false);
				int LA24_0 = input.LA(1);

				if ((LA24_0==ID||LA24_0==IF||(LA24_0>=INT && LA24_0<=LET)||LA24_0==MINUS||LA24_0==NIL||LA24_0==OP||LA24_0==STRING))
				{
					alt24 = 1;
				}
				} finally { DebugExitDecision(24); }
				switch (alt24)
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:234:14: expr_list
					{
					DebugLocation(234, 14);
					PushFollow(Follow._expr_list_in_id_expr2338);
					expr_list72=expr_list();
					PopFollow();

					stream_expr_list.Add(expr_list72.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(24); }

				DebugLocation(234, 25);
				CP73=(IToken)Match(input,CP,Follow._CP_in_id_expr2341);  
				stream_CP.Add(CP73);



				{
				// AST REWRITE
				// elements: expr_list, id
				// token labels: id
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleITokenStream stream_id=new RewriteRuleITokenStream(adaptor,"token id",id);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 234:28: -> ^( FUNCTION_CALL $id ( expr_list )? )
				{
					DebugLocation(234, 30);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:234:30: ^( FUNCTION_CALL $id ( expr_list )? )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(234, 32);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FUNCTION_CALL, "FUNCTION_CALL"), root_1);

					DebugLocation(234, 47);
					adaptor.AddChild(root_1, stream_id.NextNode());
					DebugLocation(234, 51);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:234:51: ( expr_list )?
					if (stream_expr_list.HasNext)
					{
						DebugLocation(234, 51);
						adaptor.AddChild(root_1, stream_expr_list.NextTree());

					}
					stream_expr_list.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:236:11: ASSIGN rvalue= return_expr
				{
				DebugLocation(236, 11);
				ASSIGN74=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_id_expr2374);  
				stream_ASSIGN.Add(ASSIGN74);

				DebugLocation(236, 24);
				PushFollow(Follow._return_expr_in_id_expr2378);
				rvalue=return_expr();
				PopFollow();

				stream_return_expr.Add(rvalue.Tree);


				{
				// AST REWRITE
				// elements: rvalue, id, ASSIGN
				// token labels: id
				// rule labels: retval, rvalue
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleITokenStream stream_id=new RewriteRuleITokenStream(adaptor,"token id",id);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_rvalue=new RewriteRuleSubtreeStream(adaptor,"rule rvalue",rvalue!=null?rvalue.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 236:37: -> ^( ASSIGN $id $rvalue)
				{
					DebugLocation(236, 40);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:236:40: ^( ASSIGN $id $rvalue)
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(236, 42);
					root_1 = (object)adaptor.BecomeRoot(stream_ASSIGN.NextNode(), root_1);

					DebugLocation(236, 50);
					adaptor.AddChild(root_1, stream_id.NextNode());
					DebugLocation(236, 54);
					adaptor.AddChild(root_1, stream_rvalue.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:237:11: 
				{

				{
				// AST REWRITE
				// elements: id
				// token labels: id
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleITokenStream stream_id=new RewriteRuleITokenStream(adaptor,"token id",id);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 237:11: -> $id
				{
					DebugLocation(237, 15);
					adaptor.AddChild(root_0, stream_id.NextNode());

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			} finally { DebugExitSubRule(25); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("id_expr", 12);
			LeaveRule("id_expr", 12);
			LeaveRule_id_expr();
		}
		DebugLocation(239, 4);
		} finally { DebugExitRule(GrammarFileName, "id_expr"); }
		return retval;

	}
	// $ANTLR end "id_expr"

	partial void EnterRule_expr_seq();
	partial void LeaveRule_expr_seq();

	// $ANTLR start "expr_seq"
	// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:241:1: expr_seq : expr ( SEMI ! expr )* ;
	[GrammarRule("expr_seq")]
	private AstParserRuleReturnScope<object, IToken> expr_seq()
	{
		EnterRule_expr_seq();
		EnterRule("expr_seq", 13);
		TraceIn("expr_seq", 13);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken SEMI76 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expr75 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr77 = default(AstParserRuleReturnScope<object, IToken>);

		object SEMI76_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "expr_seq");
		DebugLocation(241, 4);
		try
		{
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:242:5: ( expr ( SEMI ! expr )* )
			DebugEnterAlt(1);
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:242:9: expr ( SEMI ! expr )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(242, 9);
			PushFollow(Follow._expr_in_expr_seq2430);
			expr75=expr();
			PopFollow();

			adaptor.AddChild(root_0, expr75.Tree);
			DebugLocation(242, 14);
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:242:14: ( SEMI ! expr )*
			try { DebugEnterSubRule(26);
			while (true)
			{
				int alt26=2;
				try { DebugEnterDecision(26, false);
				int LA26_0 = input.LA(1);

				if ((LA26_0==SEMI))
				{
					alt26 = 1;
				}


				} finally { DebugExitDecision(26); }
				switch ( alt26 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:242:16: SEMI ! expr
					{
					DebugLocation(242, 20);
					SEMI76=(IToken)Match(input,SEMI,Follow._SEMI_in_expr_seq2434); 
					DebugLocation(242, 22);
					PushFollow(Follow._expr_in_expr_seq2437);
					expr77=expr();
					PopFollow();

					adaptor.AddChild(root_0, expr77.Tree);

					}
					break;

				default:
					goto loop26;
				}
			}

			loop26:
				;

			} finally { DebugExitSubRule(26); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expr_seq", 13);
			LeaveRule("expr_seq", 13);
			LeaveRule_expr_seq();
		}
		DebugLocation(243, 4);
		} finally { DebugExitRule(GrammarFileName, "expr_seq"); }
		return retval;

	}
	// $ANTLR end "expr_seq"

	partial void EnterRule_expr_list();
	partial void LeaveRule_expr_list();

	// $ANTLR start "expr_list"
	// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:245:1: expr_list : return_expr ( COMMA return_expr )* -> ^( ARGUMENT ( return_expr )+ ) ;
	[GrammarRule("expr_list")]
	private AstParserRuleReturnScope<object, IToken> expr_list()
	{
		EnterRule_expr_list();
		EnterRule("expr_list", 14);
		TraceIn("expr_list", 14);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken COMMA79 = default(IToken);
		AstParserRuleReturnScope<object, IToken> return_expr78 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> return_expr80 = default(AstParserRuleReturnScope<object, IToken>);

		object COMMA79_tree = default(object);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_return_expr=new RewriteRuleSubtreeStream(adaptor,"rule return_expr");
		try { DebugEnterRule(GrammarFileName, "expr_list");
		DebugLocation(245, 4);
		try
		{
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:246:5: ( return_expr ( COMMA return_expr )* -> ^( ARGUMENT ( return_expr )+ ) )
			DebugEnterAlt(1);
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:246:9: return_expr ( COMMA return_expr )*
			{
			DebugLocation(246, 9);
			PushFollow(Follow._return_expr_in_expr_list2463);
			return_expr78=return_expr();
			PopFollow();

			stream_return_expr.Add(return_expr78.Tree);
			DebugLocation(246, 21);
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:246:21: ( COMMA return_expr )*
			try { DebugEnterSubRule(27);
			while (true)
			{
				int alt27=2;
				try { DebugEnterDecision(27, false);
				int LA27_0 = input.LA(1);

				if ((LA27_0==COMMA))
				{
					alt27 = 1;
				}


				} finally { DebugExitDecision(27); }
				switch ( alt27 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:246:22: COMMA return_expr
					{
					DebugLocation(246, 22);
					COMMA79=(IToken)Match(input,COMMA,Follow._COMMA_in_expr_list2466);  
					stream_COMMA.Add(COMMA79);

					DebugLocation(246, 28);
					PushFollow(Follow._return_expr_in_expr_list2468);
					return_expr80=return_expr();
					PopFollow();

					stream_return_expr.Add(return_expr80.Tree);

					}
					break;

				default:
					goto loop27;
				}
			}

			loop27:
				;

			} finally { DebugExitSubRule(27); }



			{
			// AST REWRITE
			// elements: return_expr
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 246:42: -> ^( ARGUMENT ( return_expr )+ )
			{
				DebugLocation(246, 45);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:246:45: ^( ARGUMENT ( return_expr )+ )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(246, 47);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ARGUMENT, "ARGUMENT"), root_1);

				DebugLocation(246, 56);
				if (!(stream_return_expr.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_return_expr.HasNext )
				{
					DebugLocation(246, 56);
					adaptor.AddChild(root_1, stream_return_expr.NextTree());

				}
				stream_return_expr.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expr_list", 14);
			LeaveRule("expr_list", 14);
			LeaveRule_expr_list();
		}
		DebugLocation(247, 4);
		} finally { DebugExitRule(GrammarFileName, "expr_list"); }
		return retval;

	}
	// $ANTLR end "expr_list"

	partial void EnterRule_field_list();
	partial void LeaveRule_field_list();

	// $ANTLR start "field_list"
	// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:249:1: field_list : ID EQUAL return_expr ( COMMA ID EQUAL return_expr )* -> ( ^( FIELD_ASSIGN ID return_expr ) )+ ;
	[GrammarRule("field_list")]
	private AstParserRuleReturnScope<object, IToken> field_list()
	{
		EnterRule_field_list();
		EnterRule("field_list", 15);
		TraceIn("field_list", 15);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID81 = default(IToken);
		IToken EQUAL82 = default(IToken);
		IToken COMMA84 = default(IToken);
		IToken ID85 = default(IToken);
		IToken EQUAL86 = default(IToken);
		AstParserRuleReturnScope<object, IToken> return_expr83 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> return_expr87 = default(AstParserRuleReturnScope<object, IToken>);

		object ID81_tree = default(object);
		object EQUAL82_tree = default(object);
		object COMMA84_tree = default(object);
		object ID85_tree = default(object);
		object EQUAL86_tree = default(object);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleITokenStream stream_EQUAL=new RewriteRuleITokenStream(adaptor,"token EQUAL");
		RewriteRuleSubtreeStream stream_return_expr=new RewriteRuleSubtreeStream(adaptor,"rule return_expr");
		try { DebugEnterRule(GrammarFileName, "field_list");
		DebugLocation(249, 4);
		try
		{
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:250:5: ( ID EQUAL return_expr ( COMMA ID EQUAL return_expr )* -> ( ^( FIELD_ASSIGN ID return_expr ) )+ )
			DebugEnterAlt(1);
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:250:9: ID EQUAL return_expr ( COMMA ID EQUAL return_expr )*
			{
			DebugLocation(250, 9);
			ID81=(IToken)Match(input,ID,Follow._ID_in_field_list2503);  
			stream_ID.Add(ID81);

			DebugLocation(250, 12);
			EQUAL82=(IToken)Match(input,EQUAL,Follow._EQUAL_in_field_list2505);  
			stream_EQUAL.Add(EQUAL82);

			DebugLocation(250, 18);
			PushFollow(Follow._return_expr_in_field_list2507);
			return_expr83=return_expr();
			PopFollow();

			stream_return_expr.Add(return_expr83.Tree);
			DebugLocation(250, 30);
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:250:30: ( COMMA ID EQUAL return_expr )*
			try { DebugEnterSubRule(28);
			while (true)
			{
				int alt28=2;
				try { DebugEnterDecision(28, false);
				int LA28_0 = input.LA(1);

				if ((LA28_0==COMMA))
				{
					alt28 = 1;
				}


				} finally { DebugExitDecision(28); }
				switch ( alt28 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:250:32: COMMA ID EQUAL return_expr
					{
					DebugLocation(250, 32);
					COMMA84=(IToken)Match(input,COMMA,Follow._COMMA_in_field_list2511);  
					stream_COMMA.Add(COMMA84);

					DebugLocation(250, 38);
					ID85=(IToken)Match(input,ID,Follow._ID_in_field_list2513);  
					stream_ID.Add(ID85);

					DebugLocation(250, 41);
					EQUAL86=(IToken)Match(input,EQUAL,Follow._EQUAL_in_field_list2515);  
					stream_EQUAL.Add(EQUAL86);

					DebugLocation(250, 47);
					PushFollow(Follow._return_expr_in_field_list2517);
					return_expr87=return_expr();
					PopFollow();

					stream_return_expr.Add(return_expr87.Tree);

					}
					break;

				default:
					goto loop28;
				}
			}

			loop28:
				;

			} finally { DebugExitSubRule(28); }



			{
			// AST REWRITE
			// elements: ID, return_expr
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 250:62: -> ( ^( FIELD_ASSIGN ID return_expr ) )+
			{
				DebugLocation(250, 66);
				if (!(stream_ID.HasNext||stream_return_expr.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_ID.HasNext||stream_return_expr.HasNext )
				{
					DebugLocation(250, 66);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:250:66: ^( FIELD_ASSIGN ID return_expr )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(250, 68);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FIELD_ASSIGN, "FIELD_ASSIGN"), root_1);

					DebugLocation(250, 81);
					adaptor.AddChild(root_1, stream_ID.NextNode());
					DebugLocation(250, 84);
					adaptor.AddChild(root_1, stream_return_expr.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				stream_ID.Reset();
				stream_return_expr.Reset();

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("field_list", 15);
			LeaveRule("field_list", 15);
			LeaveRule_field_list();
		}
		DebugLocation(251, 4);
		} finally { DebugExitRule(GrammarFileName, "field_list"); }
		return retval;

	}
	// $ANTLR end "field_list"

	partial void EnterRule_declaration_list();
	partial void LeaveRule_declaration_list();

	// $ANTLR start "declaration_list"
	// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:253:1: declaration_list : ( declaration )+ -> ^( DEC_LIST ( declaration )+ ) ;
	[GrammarRule("declaration_list")]
	private AstParserRuleReturnScope<object, IToken> declaration_list()
	{
		EnterRule_declaration_list();
		EnterRule("declaration_list", 16);
		TraceIn("declaration_list", 16);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> declaration88 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_declaration=new RewriteRuleSubtreeStream(adaptor,"rule declaration");
		try { DebugEnterRule(GrammarFileName, "declaration_list");
		DebugLocation(253, 4);
		try
		{
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:254:5: ( ( declaration )+ -> ^( DEC_LIST ( declaration )+ ) )
			DebugEnterAlt(1);
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:254:9: ( declaration )+
			{
			DebugLocation(254, 9);
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:254:9: ( declaration )+
			int cnt29=0;
			try { DebugEnterSubRule(29);
			while (true)
			{
				int alt29=2;
				try { DebugEnterDecision(29, false);
				int LA29_0 = input.LA(1);

				if ((LA29_0==FUNCTION||LA29_0==TYPE||LA29_0==VAR))
				{
					alt29 = 1;
				}


				} finally { DebugExitDecision(29); }
				switch (alt29)
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:254:9: declaration
					{
					DebugLocation(254, 9);
					PushFollow(Follow._declaration_in_declaration_list2551);
					declaration88=declaration();
					PopFollow();

					stream_declaration.Add(declaration88.Tree);

					}
					break;

				default:
					if (cnt29 >= 1)
						goto loop29;

					EarlyExitException eee29 = new EarlyExitException( 29, input );
					DebugRecognitionException(eee29);
					throw eee29;
				}
				cnt29++;
			}
			loop29:
				;

			} finally { DebugExitSubRule(29); }



			{
			// AST REWRITE
			// elements: declaration
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 254:22: -> ^( DEC_LIST ( declaration )+ )
			{
				DebugLocation(254, 25);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:254:25: ^( DEC_LIST ( declaration )+ )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(254, 27);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(DEC_LIST, "DEC_LIST"), root_1);

				DebugLocation(254, 36);
				if (!(stream_declaration.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_declaration.HasNext )
				{
					DebugLocation(254, 36);
					adaptor.AddChild(root_1, stream_declaration.NextTree());

				}
				stream_declaration.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("declaration_list", 16);
			LeaveRule("declaration_list", 16);
			LeaveRule_declaration_list();
		}
		DebugLocation(255, 4);
		} finally { DebugExitRule(GrammarFileName, "declaration_list"); }
		return retval;

	}
	// $ANTLR end "declaration_list"

	partial void EnterRule_declaration();
	partial void LeaveRule_declaration();

	// $ANTLR start "declaration"
	// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:257:1: declaration : ( type_declaration | variable_declaration | function_declaration );
	[GrammarRule("declaration")]
	private AstParserRuleReturnScope<object, IToken> declaration()
	{
		EnterRule_declaration();
		EnterRule("declaration", 17);
		TraceIn("declaration", 17);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> type_declaration89 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> variable_declaration90 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> function_declaration91 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "declaration");
		DebugLocation(257, 4);
		try
		{
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:258:5: ( type_declaration | variable_declaration | function_declaration )
			int alt30=3;
			try { DebugEnterDecision(30, false);
			switch (input.LA(1))
			{
			case TYPE:
				{
				alt30 = 1;
				}
				break;
			case VAR:
				{
				alt30 = 2;
				}
				break;
			case FUNCTION:
				{
				alt30 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 30, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(30); }
			switch (alt30)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:258:9: type_declaration
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(258, 9);
				PushFollow(Follow._type_declaration_in_declaration2580);
				type_declaration89=type_declaration();
				PopFollow();

				adaptor.AddChild(root_0, type_declaration89.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:259:9: variable_declaration
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(259, 9);
				PushFollow(Follow._variable_declaration_in_declaration2590);
				variable_declaration90=variable_declaration();
				PopFollow();

				adaptor.AddChild(root_0, variable_declaration90.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:260:9: function_declaration
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(260, 9);
				PushFollow(Follow._function_declaration_in_declaration2600);
				function_declaration91=function_declaration();
				PopFollow();

				adaptor.AddChild(root_0, function_declaration91.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("declaration", 17);
			LeaveRule("declaration", 17);
			LeaveRule_declaration();
		}
		DebugLocation(261, 4);
		} finally { DebugExitRule(GrammarFileName, "declaration"); }
		return retval;

	}
	// $ANTLR end "declaration"

	partial void EnterRule_type_declaration();
	partial void LeaveRule_type_declaration();

	// $ANTLR start "type_declaration"
	// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:263:1: type_declaration : TYPE type_id= ID EQUAL (id= ID -> ^( ALIAS_DEC $type_id $id) | OBRACE ( type_fields )? CBRACE -> ^( RECORD_DEC $type_id ( type_fields )? ) | ARRAY OF type= ID -> ^( ARRAY_DEC $type_id $type) ) ;
	[GrammarRule("type_declaration")]
	private AstParserRuleReturnScope<object, IToken> type_declaration()
	{
		EnterRule_type_declaration();
		EnterRule("type_declaration", 18);
		TraceIn("type_declaration", 18);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken type_id = default(IToken);
		IToken id = default(IToken);
		IToken type = default(IToken);
		IToken TYPE92 = default(IToken);
		IToken EQUAL93 = default(IToken);
		IToken OBRACE94 = default(IToken);
		IToken CBRACE96 = default(IToken);
		IToken ARRAY97 = default(IToken);
		IToken OF98 = default(IToken);
		AstParserRuleReturnScope<object, IToken> type_fields95 = default(AstParserRuleReturnScope<object, IToken>);

		object type_id_tree = default(object);
		object id_tree = default(object);
		object type_tree = default(object);
		object TYPE92_tree = default(object);
		object EQUAL93_tree = default(object);
		object OBRACE94_tree = default(object);
		object CBRACE96_tree = default(object);
		object ARRAY97_tree = default(object);
		object OF98_tree = default(object);
		RewriteRuleITokenStream stream_OBRACE=new RewriteRuleITokenStream(adaptor,"token OBRACE");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_OF=new RewriteRuleITokenStream(adaptor,"token OF");
		RewriteRuleITokenStream stream_CBRACE=new RewriteRuleITokenStream(adaptor,"token CBRACE");
		RewriteRuleITokenStream stream_ARRAY=new RewriteRuleITokenStream(adaptor,"token ARRAY");
		RewriteRuleITokenStream stream_EQUAL=new RewriteRuleITokenStream(adaptor,"token EQUAL");
		RewriteRuleITokenStream stream_TYPE=new RewriteRuleITokenStream(adaptor,"token TYPE");
		RewriteRuleSubtreeStream stream_type_fields=new RewriteRuleSubtreeStream(adaptor,"rule type_fields");
		try { DebugEnterRule(GrammarFileName, "type_declaration");
		DebugLocation(263, 4);
		try
		{
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:264:5: ( TYPE type_id= ID EQUAL (id= ID -> ^( ALIAS_DEC $type_id $id) | OBRACE ( type_fields )? CBRACE -> ^( RECORD_DEC $type_id ( type_fields )? ) | ARRAY OF type= ID -> ^( ARRAY_DEC $type_id $type) ) )
			DebugEnterAlt(1);
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:264:9: TYPE type_id= ID EQUAL (id= ID -> ^( ALIAS_DEC $type_id $id) | OBRACE ( type_fields )? CBRACE -> ^( RECORD_DEC $type_id ( type_fields )? ) | ARRAY OF type= ID -> ^( ARRAY_DEC $type_id $type) )
			{
			DebugLocation(264, 9);
			TYPE92=(IToken)Match(input,TYPE,Follow._TYPE_in_type_declaration2619);  
			stream_TYPE.Add(TYPE92);

			DebugLocation(264, 21);
			type_id=(IToken)Match(input,ID,Follow._ID_in_type_declaration2623);  
			stream_ID.Add(type_id);

			DebugLocation(264, 25);
			EQUAL93=(IToken)Match(input,EQUAL,Follow._EQUAL_in_type_declaration2625);  
			stream_EQUAL.Add(EQUAL93);

			DebugLocation(265, 5);
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:265:5: (id= ID -> ^( ALIAS_DEC $type_id $id) | OBRACE ( type_fields )? CBRACE -> ^( RECORD_DEC $type_id ( type_fields )? ) | ARRAY OF type= ID -> ^( ARRAY_DEC $type_id $type) )
			int alt32=3;
			try { DebugEnterSubRule(32);
			try { DebugEnterDecision(32, false);
			switch (input.LA(1))
			{
			case ID:
				{
				alt32 = 1;
				}
				break;
			case OBRACE:
				{
				alt32 = 2;
				}
				break;
			case ARRAY:
				{
				alt32 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 32, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(32); }
			switch (alt32)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:266:13: id= ID
				{
				DebugLocation(266, 15);
				id=(IToken)Match(input,ID,Follow._ID_in_type_declaration2648);  
				stream_ID.Add(id);



				{
				// AST REWRITE
				// elements: id, type_id
				// token labels: id, type_id
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleITokenStream stream_id=new RewriteRuleITokenStream(adaptor,"token id",id);
				RewriteRuleITokenStream stream_type_id=new RewriteRuleITokenStream(adaptor,"token type_id",type_id);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 266:19: -> ^( ALIAS_DEC $type_id $id)
				{
					DebugLocation(266, 22);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:266:22: ^( ALIAS_DEC $type_id $id)
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(266, 24);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ALIAS_DEC, "ALIAS_DEC"), root_1);

					DebugLocation(266, 35);
					adaptor.AddChild(root_1, stream_type_id.NextNode());
					DebugLocation(266, 44);
					adaptor.AddChild(root_1, stream_id.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:267:14: OBRACE ( type_fields )? CBRACE
				{
				DebugLocation(267, 14);
				OBRACE94=(IToken)Match(input,OBRACE,Follow._OBRACE_in_type_declaration2675);  
				stream_OBRACE.Add(OBRACE94);

				DebugLocation(267, 21);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:267:21: ( type_fields )?
				int alt31=2;
				try { DebugEnterSubRule(31);
				try { DebugEnterDecision(31, false);
				int LA31_0 = input.LA(1);

				if ((LA31_0==ID))
				{
					alt31 = 1;
				}
				} finally { DebugExitDecision(31); }
				switch (alt31)
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:267:21: type_fields
					{
					DebugLocation(267, 21);
					PushFollow(Follow._type_fields_in_type_declaration2677);
					type_fields95=type_fields();
					PopFollow();

					stream_type_fields.Add(type_fields95.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(31); }

				DebugLocation(267, 34);
				CBRACE96=(IToken)Match(input,CBRACE,Follow._CBRACE_in_type_declaration2680);  
				stream_CBRACE.Add(CBRACE96);



				{
				// AST REWRITE
				// elements: type_id, type_fields
				// token labels: type_id
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleITokenStream stream_type_id=new RewriteRuleITokenStream(adaptor,"token type_id",type_id);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 267:41: -> ^( RECORD_DEC $type_id ( type_fields )? )
				{
					DebugLocation(267, 44);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:267:44: ^( RECORD_DEC $type_id ( type_fields )? )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(267, 46);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(RECORD_DEC, "RECORD_DEC"), root_1);

					DebugLocation(267, 58);
					adaptor.AddChild(root_1, stream_type_id.NextNode());
					DebugLocation(267, 66);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:267:66: ( type_fields )?
					if (stream_type_fields.HasNext)
					{
						DebugLocation(267, 66);
						adaptor.AddChild(root_1, stream_type_fields.NextTree());

					}
					stream_type_fields.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:268:14: ARRAY OF type= ID
				{
				DebugLocation(268, 14);
				ARRAY97=(IToken)Match(input,ARRAY,Follow._ARRAY_in_type_declaration2707);  
				stream_ARRAY.Add(ARRAY97);

				DebugLocation(268, 20);
				OF98=(IToken)Match(input,OF,Follow._OF_in_type_declaration2709);  
				stream_OF.Add(OF98);

				DebugLocation(268, 27);
				type=(IToken)Match(input,ID,Follow._ID_in_type_declaration2713);  
				stream_ID.Add(type);



				{
				// AST REWRITE
				// elements: type_id, type
				// token labels: type, type_id
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleITokenStream stream_type=new RewriteRuleITokenStream(adaptor,"token type",type);
				RewriteRuleITokenStream stream_type_id=new RewriteRuleITokenStream(adaptor,"token type_id",type_id);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 268:31: -> ^( ARRAY_DEC $type_id $type)
				{
					DebugLocation(268, 34);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:268:34: ^( ARRAY_DEC $type_id $type)
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(268, 36);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ARRAY_DEC, "ARRAY_DEC"), root_1);

					DebugLocation(268, 47);
					adaptor.AddChild(root_1, stream_type_id.NextNode());
					DebugLocation(268, 56);
					adaptor.AddChild(root_1, stream_type.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			} finally { DebugExitSubRule(32); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("type_declaration", 18);
			LeaveRule("type_declaration", 18);
			LeaveRule_type_declaration();
		}
		DebugLocation(270, 4);
		} finally { DebugExitRule(GrammarFileName, "type_declaration"); }
		return retval;

	}
	// $ANTLR end "type_declaration"

	partial void EnterRule_type_fields();
	partial void LeaveRule_type_fields();

	// $ANTLR start "type_fields"
	// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:272:1: type_fields : type_field ( COMMA type_field )* -> ^( FIELDS_DEC ( type_field )+ ) ;
	[GrammarRule("type_fields")]
	private AstParserRuleReturnScope<object, IToken> type_fields()
	{
		EnterRule_type_fields();
		EnterRule("type_fields", 19);
		TraceIn("type_fields", 19);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken COMMA100 = default(IToken);
		AstParserRuleReturnScope<object, IToken> type_field99 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> type_field101 = default(AstParserRuleReturnScope<object, IToken>);

		object COMMA100_tree = default(object);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_type_field=new RewriteRuleSubtreeStream(adaptor,"rule type_field");
		try { DebugEnterRule(GrammarFileName, "type_fields");
		DebugLocation(272, 4);
		try
		{
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:273:5: ( type_field ( COMMA type_field )* -> ^( FIELDS_DEC ( type_field )+ ) )
			DebugEnterAlt(1);
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:273:9: type_field ( COMMA type_field )*
			{
			DebugLocation(273, 9);
			PushFollow(Follow._type_field_in_type_fields2750);
			type_field99=type_field();
			PopFollow();

			stream_type_field.Add(type_field99.Tree);
			DebugLocation(273, 20);
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:273:20: ( COMMA type_field )*
			try { DebugEnterSubRule(33);
			while (true)
			{
				int alt33=2;
				try { DebugEnterDecision(33, false);
				int LA33_0 = input.LA(1);

				if ((LA33_0==COMMA))
				{
					alt33 = 1;
				}


				} finally { DebugExitDecision(33); }
				switch ( alt33 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:273:21: COMMA type_field
					{
					DebugLocation(273, 21);
					COMMA100=(IToken)Match(input,COMMA,Follow._COMMA_in_type_fields2753);  
					stream_COMMA.Add(COMMA100);

					DebugLocation(273, 27);
					PushFollow(Follow._type_field_in_type_fields2755);
					type_field101=type_field();
					PopFollow();

					stream_type_field.Add(type_field101.Tree);

					}
					break;

				default:
					goto loop33;
				}
			}

			loop33:
				;

			} finally { DebugExitSubRule(33); }



			{
			// AST REWRITE
			// elements: type_field
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 273:40: -> ^( FIELDS_DEC ( type_field )+ )
			{
				DebugLocation(273, 43);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:273:43: ^( FIELDS_DEC ( type_field )+ )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(273, 45);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FIELDS_DEC, "FIELDS_DEC"), root_1);

				DebugLocation(273, 56);
				if (!(stream_type_field.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_type_field.HasNext )
				{
					DebugLocation(273, 56);
					adaptor.AddChild(root_1, stream_type_field.NextTree());

				}
				stream_type_field.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("type_fields", 19);
			LeaveRule("type_fields", 19);
			LeaveRule_type_fields();
		}
		DebugLocation(274, 4);
		} finally { DebugExitRule(GrammarFileName, "type_fields"); }
		return retval;

	}
	// $ANTLR end "type_fields"

	partial void EnterRule_type_field();
	partial void LeaveRule_type_field();

	// $ANTLR start "type_field"
	// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:276:1: type_field : id= ID COLON type_id= ID -> ^( FIELD_DEC $id $type_id) ;
	[GrammarRule("type_field")]
	private AstParserRuleReturnScope<object, IToken> type_field()
	{
		EnterRule_type_field();
		EnterRule("type_field", 20);
		TraceIn("type_field", 20);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken id = default(IToken);
		IToken type_id = default(IToken);
		IToken COLON102 = default(IToken);

		object id_tree = default(object);
		object type_id_tree = default(object);
		object COLON102_tree = default(object);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		try { DebugEnterRule(GrammarFileName, "type_field");
		DebugLocation(276, 4);
		try
		{
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:277:5: (id= ID COLON type_id= ID -> ^( FIELD_DEC $id $type_id) )
			DebugEnterAlt(1);
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:277:9: id= ID COLON type_id= ID
			{
			DebugLocation(277, 11);
			id=(IToken)Match(input,ID,Follow._ID_in_type_field2791);  
			stream_ID.Add(id);

			DebugLocation(277, 15);
			COLON102=(IToken)Match(input,COLON,Follow._COLON_in_type_field2793);  
			stream_COLON.Add(COLON102);

			DebugLocation(277, 28);
			type_id=(IToken)Match(input,ID,Follow._ID_in_type_field2797);  
			stream_ID.Add(type_id);



			{
			// AST REWRITE
			// elements: type_id, id
			// token labels: id, type_id
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleITokenStream stream_id=new RewriteRuleITokenStream(adaptor,"token id",id);
			RewriteRuleITokenStream stream_type_id=new RewriteRuleITokenStream(adaptor,"token type_id",type_id);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 277:32: -> ^( FIELD_DEC $id $type_id)
			{
				DebugLocation(277, 35);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:277:35: ^( FIELD_DEC $id $type_id)
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(277, 37);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FIELD_DEC, "FIELD_DEC"), root_1);

				DebugLocation(277, 48);
				adaptor.AddChild(root_1, stream_id.NextNode());
				DebugLocation(277, 52);
				adaptor.AddChild(root_1, stream_type_id.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("type_field", 20);
			LeaveRule("type_field", 20);
			LeaveRule_type_field();
		}
		DebugLocation(278, 4);
		} finally { DebugExitRule(GrammarFileName, "type_field"); }
		return retval;

	}
	// $ANTLR end "type_field"

	partial void EnterRule_variable_declaration();
	partial void LeaveRule_variable_declaration();

	// $ANTLR start "variable_declaration"
	// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:280:1: variable_declaration : VAR id= ID ( COLON type_id= ID )? ASSIGN return_expr -> ^( VAR_DEC $id ( $type_id)? return_expr ) ;
	[GrammarRule("variable_declaration")]
	private AstParserRuleReturnScope<object, IToken> variable_declaration()
	{
		EnterRule_variable_declaration();
		EnterRule("variable_declaration", 21);
		TraceIn("variable_declaration", 21);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken id = default(IToken);
		IToken type_id = default(IToken);
		IToken VAR103 = default(IToken);
		IToken COLON104 = default(IToken);
		IToken ASSIGN105 = default(IToken);
		AstParserRuleReturnScope<object, IToken> return_expr106 = default(AstParserRuleReturnScope<object, IToken>);

		object id_tree = default(object);
		object type_id_tree = default(object);
		object VAR103_tree = default(object);
		object COLON104_tree = default(object);
		object ASSIGN105_tree = default(object);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_VAR=new RewriteRuleITokenStream(adaptor,"token VAR");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_ASSIGN=new RewriteRuleITokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_return_expr=new RewriteRuleSubtreeStream(adaptor,"rule return_expr");
		try { DebugEnterRule(GrammarFileName, "variable_declaration");
		DebugLocation(280, 4);
		try
		{
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:281:5: ( VAR id= ID ( COLON type_id= ID )? ASSIGN return_expr -> ^( VAR_DEC $id ( $type_id)? return_expr ) )
			DebugEnterAlt(1);
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:281:9: VAR id= ID ( COLON type_id= ID )? ASSIGN return_expr
			{
			DebugLocation(281, 9);
			VAR103=(IToken)Match(input,VAR,Follow._VAR_in_variable_declaration2832);  
			stream_VAR.Add(VAR103);

			DebugLocation(281, 15);
			id=(IToken)Match(input,ID,Follow._ID_in_variable_declaration2836);  
			stream_ID.Add(id);

			DebugLocation(281, 19);
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:281:19: ( COLON type_id= ID )?
			int alt34=2;
			try { DebugEnterSubRule(34);
			try { DebugEnterDecision(34, false);
			int LA34_0 = input.LA(1);

			if ((LA34_0==COLON))
			{
				alt34 = 1;
			}
			} finally { DebugExitDecision(34); }
			switch (alt34)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:281:20: COLON type_id= ID
				{
				DebugLocation(281, 20);
				COLON104=(IToken)Match(input,COLON,Follow._COLON_in_variable_declaration2839);  
				stream_COLON.Add(COLON104);

				DebugLocation(281, 33);
				type_id=(IToken)Match(input,ID,Follow._ID_in_variable_declaration2843);  
				stream_ID.Add(type_id);


				}
				break;

			}
			} finally { DebugExitSubRule(34); }

			DebugLocation(281, 39);
			ASSIGN105=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_variable_declaration2847);  
			stream_ASSIGN.Add(ASSIGN105);

			DebugLocation(281, 46);
			PushFollow(Follow._return_expr_in_variable_declaration2849);
			return_expr106=return_expr();
			PopFollow();

			stream_return_expr.Add(return_expr106.Tree);


			{
			// AST REWRITE
			// elements: return_expr, type_id, id
			// token labels: id, type_id
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleITokenStream stream_id=new RewriteRuleITokenStream(adaptor,"token id",id);
			RewriteRuleITokenStream stream_type_id=new RewriteRuleITokenStream(adaptor,"token type_id",type_id);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 281:58: -> ^( VAR_DEC $id ( $type_id)? return_expr )
			{
				DebugLocation(281, 61);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:281:61: ^( VAR_DEC $id ( $type_id)? return_expr )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(281, 63);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(VAR_DEC, "VAR_DEC"), root_1);

				DebugLocation(281, 72);
				adaptor.AddChild(root_1, stream_id.NextNode());
				DebugLocation(281, 76);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:281:76: ( $type_id)?
				if (stream_type_id.HasNext)
				{
					DebugLocation(281, 76);
					adaptor.AddChild(root_1, stream_type_id.NextNode());

				}
				stream_type_id.Reset();
				DebugLocation(281, 85);
				adaptor.AddChild(root_1, stream_return_expr.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("variable_declaration", 21);
			LeaveRule("variable_declaration", 21);
			LeaveRule_variable_declaration();
		}
		DebugLocation(282, 4);
		} finally { DebugExitRule(GrammarFileName, "variable_declaration"); }
		return retval;

	}
	// $ANTLR end "variable_declaration"

	partial void EnterRule_function_declaration();
	partial void LeaveRule_function_declaration();

	// $ANTLR start "function_declaration"
	// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:284:1: function_declaration : FUNCTION id= ID OP (args= type_fields )? CP ( EQUAL expr -> ^( PROC_DEC $id ( $args)? expr ) | COLON type_id= ID EQUAL return_expr -> ^( FUNCTION_DEC $id ( $args)? $type_id return_expr ) ) ;
	[GrammarRule("function_declaration")]
	private AstParserRuleReturnScope<object, IToken> function_declaration()
	{
		EnterRule_function_declaration();
		EnterRule("function_declaration", 22);
		TraceIn("function_declaration", 22);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken id = default(IToken);
		IToken type_id = default(IToken);
		IToken FUNCTION107 = default(IToken);
		IToken OP108 = default(IToken);
		IToken CP109 = default(IToken);
		IToken EQUAL110 = default(IToken);
		IToken COLON112 = default(IToken);
		IToken EQUAL113 = default(IToken);
		AstParserRuleReturnScope<object, IToken> args = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr111 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> return_expr114 = default(AstParserRuleReturnScope<object, IToken>);

		object id_tree = default(object);
		object type_id_tree = default(object);
		object FUNCTION107_tree = default(object);
		object OP108_tree = default(object);
		object CP109_tree = default(object);
		object EQUAL110_tree = default(object);
		object COLON112_tree = default(object);
		object EQUAL113_tree = default(object);
		RewriteRuleITokenStream stream_FUNCTION=new RewriteRuleITokenStream(adaptor,"token FUNCTION");
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_CP=new RewriteRuleITokenStream(adaptor,"token CP");
		RewriteRuleITokenStream stream_OP=new RewriteRuleITokenStream(adaptor,"token OP");
		RewriteRuleITokenStream stream_EQUAL=new RewriteRuleITokenStream(adaptor,"token EQUAL");
		RewriteRuleSubtreeStream stream_type_fields=new RewriteRuleSubtreeStream(adaptor,"rule type_fields");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		RewriteRuleSubtreeStream stream_return_expr=new RewriteRuleSubtreeStream(adaptor,"rule return_expr");
		try { DebugEnterRule(GrammarFileName, "function_declaration");
		DebugLocation(284, 4);
		try
		{
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:285:5: ( FUNCTION id= ID OP (args= type_fields )? CP ( EQUAL expr -> ^( PROC_DEC $id ( $args)? expr ) | COLON type_id= ID EQUAL return_expr -> ^( FUNCTION_DEC $id ( $args)? $type_id return_expr ) ) )
			DebugEnterAlt(1);
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:285:9: FUNCTION id= ID OP (args= type_fields )? CP ( EQUAL expr -> ^( PROC_DEC $id ( $args)? expr ) | COLON type_id= ID EQUAL return_expr -> ^( FUNCTION_DEC $id ( $args)? $type_id return_expr ) )
			{
			DebugLocation(285, 9);
			FUNCTION107=(IToken)Match(input,FUNCTION,Follow._FUNCTION_in_function_declaration2883);  
			stream_FUNCTION.Add(FUNCTION107);

			DebugLocation(285, 20);
			id=(IToken)Match(input,ID,Follow._ID_in_function_declaration2887);  
			stream_ID.Add(id);

			DebugLocation(285, 24);
			OP108=(IToken)Match(input,OP,Follow._OP_in_function_declaration2889);  
			stream_OP.Add(OP108);

			DebugLocation(285, 31);
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:285:31: (args= type_fields )?
			int alt35=2;
			try { DebugEnterSubRule(35);
			try { DebugEnterDecision(35, false);
			int LA35_0 = input.LA(1);

			if ((LA35_0==ID))
			{
				alt35 = 1;
			}
			} finally { DebugExitDecision(35); }
			switch (alt35)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:285:31: args= type_fields
				{
				DebugLocation(285, 31);
				PushFollow(Follow._type_fields_in_function_declaration2893);
				args=type_fields();
				PopFollow();

				stream_type_fields.Add(args.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(35); }

			DebugLocation(285, 45);
			CP109=(IToken)Match(input,CP,Follow._CP_in_function_declaration2896);  
			stream_CP.Add(CP109);

			DebugLocation(286, 5);
			// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:286:5: ( EQUAL expr -> ^( PROC_DEC $id ( $args)? expr ) | COLON type_id= ID EQUAL return_expr -> ^( FUNCTION_DEC $id ( $args)? $type_id return_expr ) )
			int alt36=2;
			try { DebugEnterSubRule(36);
			try { DebugEnterDecision(36, false);
			int LA36_0 = input.LA(1);

			if ((LA36_0==EQUAL))
			{
				alt36 = 1;
			}
			else if ((LA36_0==COLON))
			{
				alt36 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 36, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(36); }
			switch (alt36)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:287:9: EQUAL expr
				{
				DebugLocation(287, 9);
				EQUAL110=(IToken)Match(input,EQUAL,Follow._EQUAL_in_function_declaration2913);  
				stream_EQUAL.Add(EQUAL110);

				DebugLocation(287, 15);
				PushFollow(Follow._expr_in_function_declaration2915);
				expr111=expr();
				PopFollow();

				stream_expr.Add(expr111.Tree);


				{
				// AST REWRITE
				// elements: id, expr, args
				// token labels: id
				// rule labels: retval, args
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleITokenStream stream_id=new RewriteRuleITokenStream(adaptor,"token id",id);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_args=new RewriteRuleSubtreeStream(adaptor,"rule args",args!=null?args.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 287:32: -> ^( PROC_DEC $id ( $args)? expr )
				{
					DebugLocation(287, 35);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:287:35: ^( PROC_DEC $id ( $args)? expr )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(287, 37);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(PROC_DEC, "PROC_DEC"), root_1);

					DebugLocation(287, 47);
					adaptor.AddChild(root_1, stream_id.NextNode());
					DebugLocation(287, 51);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:287:51: ( $args)?
					if (stream_args.HasNext)
					{
						DebugLocation(287, 51);
						adaptor.AddChild(root_1, stream_args.NextTree());

					}
					stream_args.Reset();
					DebugLocation(287, 57);
					adaptor.AddChild(root_1, stream_expr.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:288:14: COLON type_id= ID EQUAL return_expr
				{
				DebugLocation(288, 14);
				COLON112=(IToken)Match(input,COLON,Follow._COLON_in_function_declaration2957);  
				stream_COLON.Add(COLON112);

				DebugLocation(288, 28);
				type_id=(IToken)Match(input,ID,Follow._ID_in_function_declaration2963);  
				stream_ID.Add(type_id);

				DebugLocation(288, 33);
				EQUAL113=(IToken)Match(input,EQUAL,Follow._EQUAL_in_function_declaration2965);  
				stream_EQUAL.Add(EQUAL113);

				DebugLocation(288, 39);
				PushFollow(Follow._return_expr_in_function_declaration2967);
				return_expr114=return_expr();
				PopFollow();

				stream_return_expr.Add(return_expr114.Tree);


				{
				// AST REWRITE
				// elements: return_expr, type_id, args, id
				// token labels: id, type_id
				// rule labels: retval, args
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleITokenStream stream_id=new RewriteRuleITokenStream(adaptor,"token id",id);
				RewriteRuleITokenStream stream_type_id=new RewriteRuleITokenStream(adaptor,"token type_id",type_id);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
				RewriteRuleSubtreeStream stream_args=new RewriteRuleSubtreeStream(adaptor,"rule args",args!=null?args.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 288:51: -> ^( FUNCTION_DEC $id ( $args)? $type_id return_expr )
				{
					DebugLocation(288, 54);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:288:54: ^( FUNCTION_DEC $id ( $args)? $type_id return_expr )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(288, 56);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FUNCTION_DEC, "FUNCTION_DEC"), root_1);

					DebugLocation(288, 70);
					adaptor.AddChild(root_1, stream_id.NextNode());
					DebugLocation(288, 74);
					// E:\\SCHOOL!!!\\Computer Science\\Tiger\\Proyecto de Compilación 10.3.14\\CODIGO\\Tiger\\Tiger\\00 ANTLR\\tiger.g:288:74: ( $args)?
					if (stream_args.HasNext)
					{
						DebugLocation(288, 74);
						adaptor.AddChild(root_1, stream_args.NextTree());

					}
					stream_args.Reset();
					DebugLocation(288, 81);
					adaptor.AddChild(root_1, stream_type_id.NextNode());
					DebugLocation(288, 89);
					adaptor.AddChild(root_1, stream_return_expr.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			} finally { DebugExitSubRule(36); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("function_declaration", 22);
			LeaveRule("function_declaration", 22);
			LeaveRule_function_declaration();
		}
		DebugLocation(290, 4);
		} finally { DebugExitRule(GrammarFileName, "function_declaration"); }
		return retval;

	}
	// $ANTLR end "function_declaration"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _expr_in_program1232 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_program1234 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _return_expr_in_expr1261 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _non_return_expr_in_expr1271 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _binary_expression_in_return_expr1290 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WHILE_in_non_return_expr1318 = new BitSet(new ulong[]{0x851A80000000000UL,0x8UL});
		public static readonly BitSet _return_expr_in_non_return_expr1322 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _DO_in_non_return_expr1324 = new BitSet(new ulong[]{0x851A82000002000UL,0x808UL});
		public static readonly BitSet _expr_in_non_return_expr1328 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FOR_in_non_return_expr1351 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _ID_in_non_return_expr1353 = new BitSet(new ulong[]{0x1000UL});
		public static readonly BitSet _ASSIGN_in_non_return_expr1355 = new BitSet(new ulong[]{0x851A80000000000UL,0x8UL});
		public static readonly BitSet _return_expr_in_non_return_expr1359 = new BitSet(new ulong[]{0x0UL,0x20UL});
		public static readonly BitSet _TO_in_non_return_expr1361 = new BitSet(new ulong[]{0x851A80000000000UL,0x8UL});
		public static readonly BitSet _return_expr_in_non_return_expr1365 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _DO_in_non_return_expr1367 = new BitSet(new ulong[]{0x851A82000002000UL,0x808UL});
		public static readonly BitSet _expr_in_non_return_expr1371 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BREAK_in_non_return_expr1400 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _and_expression_in_binary_expression1424 = new BitSet(new ulong[]{0x1000000000000002UL});
		public static readonly BitSet _OR_in_binary_expression1427 = new BitSet(new ulong[]{0x851A80000000000UL,0x8UL});
		public static readonly BitSet _and_expression_in_binary_expression1430 = new BitSet(new ulong[]{0x1000000000000002UL});
		public static readonly BitSet _comparison_expression_in_and_expression1455 = new BitSet(new ulong[]{0x22UL});
		public static readonly BitSet _AND_in_and_expression1458 = new BitSet(new ulong[]{0x851A80000000000UL,0x8UL});
		public static readonly BitSet _comparison_expression_in_and_expression1461 = new BitSet(new ulong[]{0x22UL});
		public static readonly BitSet _addition_expression_in_comparison_expression1482 = new BitSet(new ulong[]{0xC060040800002UL});
		public static readonly BitSet _EQUAL_in_comparison_expression1486 = new BitSet(new ulong[]{0x851A80000000000UL,0x8UL});
		public static readonly BitSet _DIF_in_comparison_expression1489 = new BitSet(new ulong[]{0x851A80000000000UL,0x8UL});
		public static readonly BitSet _LT_in_comparison_expression1492 = new BitSet(new ulong[]{0x851A80000000000UL,0x8UL});
		public static readonly BitSet _LTE_in_comparison_expression1496 = new BitSet(new ulong[]{0x851A80000000000UL,0x8UL});
		public static readonly BitSet _GT_in_comparison_expression1500 = new BitSet(new ulong[]{0x851A80000000000UL,0x8UL});
		public static readonly BitSet _GTE_in_comparison_expression1504 = new BitSet(new ulong[]{0x851A80000000000UL,0x8UL});
		public static readonly BitSet _addition_expression_in_comparison_expression1508 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _term_in_addition_expression1529 = new BitSet(new ulong[]{0x2010000000000002UL});
		public static readonly BitSet _PLUS_in_addition_expression1533 = new BitSet(new ulong[]{0x851A80000000000UL,0x8UL});
		public static readonly BitSet _MINUS_in_addition_expression1536 = new BitSet(new ulong[]{0x851A80000000000UL,0x8UL});
		public static readonly BitSet _term_in_addition_expression1540 = new BitSet(new ulong[]{0x2010000000000002UL});
		public static readonly BitSet _factor_in_term1561 = new BitSet(new ulong[]{0x20000001000002UL});
		public static readonly BitSet _MULT_in_term1565 = new BitSet(new ulong[]{0x851A80000000000UL,0x8UL});
		public static readonly BitSet _DIV_in_term1568 = new BitSet(new ulong[]{0x851A80000000000UL,0x8UL});
		public static readonly BitSet _factor_in_term1572 = new BitSet(new ulong[]{0x20000001000002UL});
		public static readonly BitSet _INT_in_factor1593 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MINUS_in_factor1604 = new BitSet(new ulong[]{0x851A80000000000UL,0x8UL});
		public static readonly BitSet _factor_in_factor1606 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IF_in_factor1623 = new BitSet(new ulong[]{0x851A80000000000UL,0x8UL});
		public static readonly BitSet _return_expr_in_factor1629 = new BitSet(new ulong[]{0x0UL,0x10UL});
		public static readonly BitSet _THEN_in_factor1631 = new BitSet(new ulong[]{0x851A82000002000UL,0x808UL});
		public static readonly BitSet _expr_in_factor1635 = new BitSet(new ulong[]{0x10000002UL});
		public static readonly BitSet _ELSE_in_factor1638 = new BitSet(new ulong[]{0x851A82000002000UL,0x808UL});
		public static readonly BitSet _expr_in_factor1642 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LET_in_factor1670 = new BitSet(new ulong[]{0x4000000000UL,0x240UL});
		public static readonly BitSet _declaration_list_in_factor1672 = new BitSet(new ulong[]{0x400000000000UL});
		public static readonly BitSet _IN_in_factor1674 = new BitSet(new ulong[]{0x851A82020002000UL,0x808UL});
		public static readonly BitSet _expr_seq_in_factor1676 = new BitSet(new ulong[]{0x20000000UL});
		public static readonly BitSet _END_in_factor1680 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_in_factor1706 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NIL_in_factor1716 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _id_expr_in_factor1726 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OP_in_factor1736 = new BitSet(new ulong[]{0x851A82000102000UL,0x808UL});
		public static readonly BitSet _expr_seq_in_factor1738 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _CP_in_factor1741 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DOT_in_indexer_expr1770 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _ID_in_indexer_expr1772 = new BitSet(new ulong[]{0x80000004000002UL});
		public static readonly BitSet _indexer_expr_in_indexer_expr1774 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OB_in_indexer_expr1796 = new BitSet(new ulong[]{0x851A80000000000UL,0x8UL});
		public static readonly BitSet _return_expr_in_indexer_expr1798 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _CB_in_indexer_expr1800 = new BitSet(new ulong[]{0x80000004000002UL});
		public static readonly BitSet _indexer_expr_in_indexer_expr1802 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_id_expr1835 = new BitSet(new ulong[]{0x980000004001002UL});
		public static readonly BitSet _OBRACE_in_id_expr1861 = new BitSet(new ulong[]{0x80000008000UL});
		public static readonly BitSet _field_list_in_id_expr1863 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _CBRACE_in_id_expr1866 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OB_in_id_expr1916 = new BitSet(new ulong[]{0x851A80000000000UL,0x8UL});
		public static readonly BitSet _return_expr_in_id_expr1920 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _CB_in_id_expr1922 = new BitSet(new ulong[]{0x480000004001002UL});
		public static readonly BitSet _OF_in_id_expr1935 = new BitSet(new ulong[]{0x851A80000000000UL,0x8UL});
		public static readonly BitSet _return_expr_in_id_expr1939 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _indexer_expr_in_id_expr1982 = new BitSet(new ulong[]{0x1002UL});
		public static readonly BitSet _ASSIGN_in_id_expr2044 = new BitSet(new ulong[]{0x851A80000000000UL,0x8UL});
		public static readonly BitSet _return_expr_in_id_expr2048 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DOT_in_id_expr2204 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _ID_in_id_expr2208 = new BitSet(new ulong[]{0x80000004001002UL});
		public static readonly BitSet _indexer_expr_in_id_expr2210 = new BitSet(new ulong[]{0x1002UL});
		public static readonly BitSet _ASSIGN_in_id_expr2233 = new BitSet(new ulong[]{0x851A80000000000UL,0x8UL});
		public static readonly BitSet _return_expr_in_id_expr2237 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OP_in_id_expr2336 = new BitSet(new ulong[]{0x851A80000100000UL,0x8UL});
		public static readonly BitSet _expr_list_in_id_expr2338 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _CP_in_id_expr2341 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ASSIGN_in_id_expr2374 = new BitSet(new ulong[]{0x851A80000000000UL,0x8UL});
		public static readonly BitSet _return_expr_in_id_expr2378 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expr_in_expr_seq2430 = new BitSet(new ulong[]{0x2UL,0x4UL});
		public static readonly BitSet _SEMI_in_expr_seq2434 = new BitSet(new ulong[]{0x851A82000002000UL,0x808UL});
		public static readonly BitSet _expr_in_expr_seq2437 = new BitSet(new ulong[]{0x2UL,0x4UL});
		public static readonly BitSet _return_expr_in_expr_list2463 = new BitSet(new ulong[]{0x40002UL});
		public static readonly BitSet _COMMA_in_expr_list2466 = new BitSet(new ulong[]{0x851A80000000000UL,0x8UL});
		public static readonly BitSet _return_expr_in_expr_list2468 = new BitSet(new ulong[]{0x40002UL});
		public static readonly BitSet _ID_in_field_list2503 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _EQUAL_in_field_list2505 = new BitSet(new ulong[]{0x851A80000000000UL,0x8UL});
		public static readonly BitSet _return_expr_in_field_list2507 = new BitSet(new ulong[]{0x40002UL});
		public static readonly BitSet _COMMA_in_field_list2511 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _ID_in_field_list2513 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _EQUAL_in_field_list2515 = new BitSet(new ulong[]{0x851A80000000000UL,0x8UL});
		public static readonly BitSet _return_expr_in_field_list2517 = new BitSet(new ulong[]{0x40002UL});
		public static readonly BitSet _declaration_in_declaration_list2551 = new BitSet(new ulong[]{0x4000000002UL,0x240UL});
		public static readonly BitSet _type_declaration_in_declaration2580 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _variable_declaration_in_declaration2590 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _function_declaration_in_declaration2600 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TYPE_in_type_declaration2619 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _ID_in_type_declaration2623 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _EQUAL_in_type_declaration2625 = new BitSet(new ulong[]{0x100080000000080UL});
		public static readonly BitSet _ID_in_type_declaration2648 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OBRACE_in_type_declaration2675 = new BitSet(new ulong[]{0x80000008000UL});
		public static readonly BitSet _type_fields_in_type_declaration2677 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _CBRACE_in_type_declaration2680 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ARRAY_in_type_declaration2707 = new BitSet(new ulong[]{0x400000000000000UL});
		public static readonly BitSet _OF_in_type_declaration2709 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _ID_in_type_declaration2713 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _type_field_in_type_fields2750 = new BitSet(new ulong[]{0x40002UL});
		public static readonly BitSet _COMMA_in_type_fields2753 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _type_field_in_type_fields2755 = new BitSet(new ulong[]{0x40002UL});
		public static readonly BitSet _ID_in_type_field2791 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _COLON_in_type_field2793 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _ID_in_type_field2797 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _VAR_in_variable_declaration2832 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _ID_in_variable_declaration2836 = new BitSet(new ulong[]{0x21000UL});
		public static readonly BitSet _COLON_in_variable_declaration2839 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _ID_in_variable_declaration2843 = new BitSet(new ulong[]{0x1000UL});
		public static readonly BitSet _ASSIGN_in_variable_declaration2847 = new BitSet(new ulong[]{0x851A80000000000UL,0x8UL});
		public static readonly BitSet _return_expr_in_variable_declaration2849 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FUNCTION_in_function_declaration2883 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _ID_in_function_declaration2887 = new BitSet(new ulong[]{0x800000000000000UL});
		public static readonly BitSet _OP_in_function_declaration2889 = new BitSet(new ulong[]{0x80000100000UL});
		public static readonly BitSet _type_fields_in_function_declaration2893 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _CP_in_function_declaration2896 = new BitSet(new ulong[]{0x40020000UL});
		public static readonly BitSet _EQUAL_in_function_declaration2913 = new BitSet(new ulong[]{0x851A82000002000UL,0x808UL});
		public static readonly BitSet _expr_in_function_declaration2915 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _COLON_in_function_declaration2957 = new BitSet(new ulong[]{0x80000000000UL});
		public static readonly BitSet _ID_in_function_declaration2963 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _EQUAL_in_function_declaration2965 = new BitSet(new ulong[]{0x851A80000000000UL,0x8UL});
		public static readonly BitSet _return_expr_in_function_declaration2967 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}
